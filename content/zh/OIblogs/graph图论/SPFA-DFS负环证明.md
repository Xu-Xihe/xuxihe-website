---
title: "SPFA-DFS负环证明"
linkTitle: "SPFA-DFS负环证明"
type: blog
weight: 5
date: 2021-10-18
description: >
  一篇小小的证明。
---

# SPFA-DFS负环证明



## 结论

让我们先来看结论：

<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/graph.png" alt="spfa" style="zoom:60%;" />

如上图，明显可以看出 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 4 构成了一个负环。

以任意节点为起点，用SPFA-DFS查找负环，则有：

​	若存在负环，则**一定**存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点**依次**相加**始终**为负。

## 正解

我们只考虑在负环上的节点(因为我们只需证明这样的点对存在，非负权边节点情况过于复杂且并不影响答案的正确性，故忽略)。

<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/%E8%B4%9F%E7%8E%AF.png" alt="fuhuan" style="zoom:67%;" />

我们对这个图重复进行如下操作：

1. 对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。
<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/1.png" alt="dsf" style="zoom:67%;" />
2. 对于一个正负权边交替相连的图，将一条负边 $i$​，$i$​ 的起止两个节点和 $i$​ 指向的正权边分为一组，求两个边权和并作为新边边权合并。新的边表示已 $i$​ 的起点为遍历起点，经过两条边之后的边权和。和为负，则说明可以走过这两条边；和为正，则说明不可以以其作为起点。
<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/2.png" style="zoom:67%;" />



第3步<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/3.png" alt="dfadf" style="zoom:67%;" />



第4步<img src="SPFA-DFS%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E.assets/4.png" alt="adf" style="zoom:67%;" />

直到图中仅剩下两个节点和两条边，这时，一定有两边之和小于0。(因为两边之和即为环上边权之和)

因此，从这时负边的起点开始遍历原来的负环，保证边权依次相加为负。

对于任意一条负边，表示从起始节点到终止节点所包含的边依次相加为负，边权为从起点走到终点后的边权和。我们每次选择的均为负边起点。

## 伪证(早期的一些想法)

首先，我们对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。

因为是负权边，所以有 $\abs{\sum^m_ival[i]|i\in{(-\infty,0)}}>\abs{\sum_i^mval[i]|i\in{(0,\infty)}}$。若存在 $i$ 正权边大于与之相邻的 $j$ 负权边，那么一定存在另一负权边绝对值大于与之相邻的正权边加 $i+j$。

对于任意负环(边权和为负的部分)，我们将它任意切割成两半，共有两种情况：

1. 任意一半的边权之和都小于 $0$​<img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.assets/graph2.png" alt="zero" style="zoom:67%;" />

2. 一半边权之和大于 $0$，另一半小于 $0$ (设两半边权之和为 $a$ 和 $b$，则有 $a+b<0$ 。所以，当 $a>0$ 时，一定有 $b<0$​ )

   <img src="%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.assets/graph1.png" alt="half" style="zoom:67%;" />

对于任意边权和为正的部分，我们将它任意切割成两半，共有两种情况：

1. 任意一半的边权和为正
2. 其中一半的边权和为负，另一半为正

我们发现，当我们对边权和为负的部分进行 $n$​ 次切割直到有至少两个部分边权和为负，并且 $\abs{\sum边权和为负的部分}>\abs{\sum边权和为正的部分}$ ​。

操作：

1. 对于任意一条最短路径，若其中有任何一个点在负环中，则其长度为 $-\infty$，并且路径上存在多次访问节点，所以当一个顶点被第二次加入最短路并且其 $dis<0$，证明有负环。
2. 很显然，我们并不能跑通常意义下的最短路(肯定比SPFA-BFS慢很多，失去意义)，而是当任何时刻$dis>0$​时终止递归。
3. 如2，我们只寻找了以起点为负环上特定顶点的情况，所以需要对每个顶点执行同样的操作。
4. 此算法理论上只需要跑一遍负环即可，而无需走 $n$ 条边。

然后就写不下去了…………

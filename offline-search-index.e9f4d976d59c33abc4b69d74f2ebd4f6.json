[{"body":"","categories":"","description":"常用C++ STL模板使用方法及例子。\n","excerpt":"常用C++ STL模板使用方法及例子。\n","ref":"/oiblogs/others%E6%9D%82%E9%A1%B9/c++-stl/","tags":"","title":"C++ STL"},{"body":"快速幂 幂还有快速？ 我们首先来思考一个问题，对于 $7^6$ 如何求。\n作为一个人类，你的求法一定是先算出 $7\\times7=49$，然后接着算出 $49\\times7=343$，…… ，$16807\\times7=117649$。因为人类并不适合算两位数以上的乘法(一位数还勉强可以瞪眼)，所以有些时候我们的思维便会限制在这个里面。\n但是，我们了解，对于计算机CPU来说 $7\\times7$ 和 $1561564\\times1561564$ 几乎没啥差别(毕竟慢的是存储)，因此我们可以加快幂运算。\n又是二进制 没错，你没看错，又是二进制！\n我们早就知道了，对于任意一个二进制数，我们可以拆分成多个 $2^n$ 相加的形式。如：$6_{10}=(110)_2=(100)_2+(10)_2=2^2+2^1$。\n相应的，任意一个数 $x$ 的 $k$ 次方 $x^k$ 都可以拆分成多个 $x^{2^n}$ 相乘的形式。这时候，我们发现，原本的 $O(k)$ 次操作被优化到了 $O(\\log{k})$。而我们只需要将 $x^{2^n}$ 不断的自己乘自己，就可以得到所有我们需要的数。\n例子：计算 $7^{14}=7^2\\times7^4\\times7^8$\n代码 [P1226 【模板】快速幂\u0026取余运算][https://www.luogu.com.cn/problem/P1226]\n//只需要注意mi函数即可 #include \u003ccstdio\u003eint a, b, p; inline int mi(int n, int m, int mod, long long sum = 1, long long ans = 1) //n表示底数,m表示指数,mod为模数,sum为累加器,ans为结果 { sum = n; //初始化累加器至n^1  while (m) //保证指数不为0  { if (m \u0026 1) //如果最后一位是1,则应该乘上  { ans *= sum; ans %= mod; } sum *= sum; //累加器自乘  sum %= mod; m \u003e\u003e= 1; //这一位已经处理完毕,开始处理下一位  } return ans % mod; } int main() { scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026p); printf(\"%d^%d mod %d=%d\\n\", a, b, p, mi(a, b, p)); //奇奇怪怪的输出方式 } 链接 其他更快的方法，参见[]、[]。\n","categories":"","description":"高速！高速！\n","excerpt":"高速！高速！\n","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E5%BF%AB%E9%80%9F%E5%B9%82/","tags":"","title":"快速幂"},{"body":"DFS 深度优先搜索。 深度优先，即每一次均搜索一条完整的从起点到达终点的路径，然后继续搜索第二条。\n原始支持有权图搜索。\n一般情况下，通常使用递归的方式实现。\n具体流程为，对于当前节点，循环遍历下一个目标节点，对于可能的目标节点调用递归函数，直到终止条件。\n状态一般包括step，记录决策的数组等，可以放在全局变量中（注意回溯时需要回退全局变量）。\n剪枝 剪枝就是切掉一部分无用的搜索树，起到优化复杂度的作用\n  **记忆化：**dfs函数中传入相同的状态往往会得到一样的解，所以用数组记录下对应每个状态的答案，若之前已求得直接返回即可。\n  **求代价和最小：**若转移时代价非负，则若目前的代价和已经大于等于之前的最小答案，直接返回。\n  更改转移的枚举顺序\n  启发式搜索 当搜索到一个状态u时，计算估价函数 $f(u)$ 的值：\n  对于转移需要代价的题目，$f(u)$ 代表转移到末状态的最小代价，如果走到u状态的代价 $g(u)+f(u)\u003eans$ 则剪枝\n  对于转移得到收益的题目，$f(u)$ 表示可能的最大收益，如果 $g(u)+f(u)≤ans$ 则剪枝\n  A* 估价函数同启发式搜索，但是我们用优先队列进行类广搜,每次取出 $f(x)+g(x)$ 最小的 $x$，然后更新相邻的状态。\nIDA* 迭代加深A*，仅仅是添加了限制层数。\nDFS生成树 在一个有向图中，以DFS的方式选取某一节点进行搜索而形成的树+边的结构。\n举个栗子：\n我们先看一个有向图：\n用DFS跑图，就可以得到一下这个：\n我们可以以树形结构将图中的边分为四种：\n  树边：每个节点第一次被访问时经过的边，整体称为搜索树。\n  返祖边：从子树中的节点到其父亲节点的边。\n  前向边：从父亲节点直接指向儿子(也可以是孙子等)节点的边。\n  横叉边：搜索的时候遇到了一个已经访问过的结点，但是这个结点并不是当前结点的祖先时形成的。(看不懂？流氓定义：如果这条边不是上面三种，那就是横叉边)\n  DFS序 字面意思，很好理解，就是用DFS前序遍历一棵树上所有节点和边时访问的顺序。\n我们知道，树是一种非线性的数据结构，它的一些数据调用肯定是没有线性结构来得方便的。所以这个时候，dfs站了出来。\n如图，这是一棵树：\n所以，整了一大顿，这DFS序到底有啥子用？这得从DFS的优势来探讨了。\nDFS是深度优先的，所以对于一个点，它会先遍历完它的所有子节点，再去遍历他的兄弟节点以及其他子树的节点。\n因此DFS序保证了一棵树(子树)的根节点和其子树中所有的节点会被存储在连续的区间之中。\n比如，以 $5$ 为根的子树中节点编号为 $5\\sim8$。\n这样，我们把一个非线性的数据结构——树，成功转化为了一个线性的数据结构，然后……请自行选择。\nBut! 我们现在还有一个问题：\n如何直到我的子树区间到哪？别搞出去就不好了。\n欲知详情，请接着看 -_-\n时间戳 这玩意好比一个标签，贴在每一个点上，记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。\n我们发现，节点 $i$ 的DFS序其实是DFS第一次访问节点 $i$ 的时间，因此我们只需要记录最后结束访问的时间即可。\n实现很简单，循环完儿子之后(回溯之前)记录一下当前最大DFS序值即可。\n这样，我们成功的把一棵树变成了一段段的区间：\nBFS 广度优先搜索。 广度优先，即每一次都搜索距离起点相同长度的点，然后继续搜索长度 $+1$ 的点，直到搜索到终点。\n原始不支持有权图，但可以使用算法优化。\n一般情况下，通常使用队列的方式实现。\n具体流程为，先将起始节点推入队列，每次循环弹出队首元素，将其加入以搜索的点集，并将与之连接的未加入以搜索的点集的点推入队列尾部，直到找到终点或者队列为空。\n双向BFS 要求 $S$ 状态到 $T$ 状态的最小转移次数，从 $S$，$T$ 分别同时出发进行BFS，直到BFS到的点相遇为止。\n理论上将深度为 $n$ 的搜索树拆分成了两棵深度为 $\\frac{n}{2}$ 的搜索树 。若决策个数为 $k$，搜索树大小由 $k^n$ 优化为 $2\\times k^\\frac{n}{2}$。\n如何判断一个局面（状态）是否被访问过？可以将全局状态变成一个整数，用map或unordered_map记录该整数是否出现过。\n三个要素  状态：怎么表示？要求包括全部信息、能够标记是否已访问。 转移：转移后的状态计算，转移代价计算。 优化：剪枝（剪掉无用的搜索子树），修改搜索顺序，估价函数。  ","categories":"","description":"在一张图上，万物以搜索为基础。\n","excerpt":"在一张图上，万物以搜索为基础。\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%90%9C%E7%B4%A2/","tags":"","title":"搜索"},{"body":"普通并查集 引子 脑洞蛮大的一个东西，自己还改了改\n​ 江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。 ​ 但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。 ​ 这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。 ​ 但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？\n​ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“周翡队”“谢允队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。\n​ 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长(抓狂!)。要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？” ​ 这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限死循环中。 ​ 于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，队长就是根节点，下面分别是二级军官、三级小兵……每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。 ​ 由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。\n​ 现在，我们用fa[i]数组记录编号为i的大侠上级的编号。如果fa[i]==i，则i号大侠是队长。而find函数这是用来寻找队长的。 ​ 我非常喜欢周翡与谢允，他们分别属于四十八寨和皇亲国戚，那明显就是两个阵营了。我不希望他们互相打架~~(磕糖没够)~~，就对他俩说：“你们两位拉拉勾，做好(x)朋(q)友(l)吧。” ​ 他们看在我的面子上，同意了(我脸真大)。这一同意可非同小可，整个四十八寨和皇帝的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？ ​ 其实非常简单，我对谢允说：“大师，麻烦你把你的上级改为周翡吧。这样一来，两派原先的所有人员的终极boss都是周翡，那还打个球啊！”谢允一听肯定火大了：“我艹，凭什么是我变成她手下呀，怎么不反过来？我抗议！”\n(大笑)(反正我们关心的只是连通性，门派内部的结构不要紧的，人家家事也不好管的。)\n​ 于是，两人相约一战，杀的是天昏地暗，风云为之变色啊。但是啊，这场战争终究会有胜负，胜者为王，弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。而together函数就是用来合并门派的。\n​ 两个互不相识的大侠碰面了，想知道能不能干一场。于是赶紧打电话问自己的上级：“你是不是掌门？”上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” ​ 一路问下去，原来两人的队长都是周翡。“哎呀呀，原来是自己人，有礼有礼，在下岐兰山盘龙洞白面葫芦娃!”“幸会幸会，在下万仙山暖香阁狗尾(yi)巴花！”两人高高兴兴地手拉手喝酒去了。“等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。“哦，对了，还要做路径压缩。”两人醒悟。(find) ​ 白面葫芦娃打电话给他的上级六掌门：“组长啊，我查过了，其实偶们的掌门是周翡。不如偶们一起结拜在周翡手下吧，省得级别太低，以后查找掌门麻烦。” ​ “唔，有道理。”白面葫芦娃接着打电话给刚才拜访过的三执事……仙子狗尾巴花也做了同样的事情。 ​ 这样一来，整个门派树的层数都会维持在比较低的水平上，便于查找。\n开始了 乐呵够了，开始了…………\n上述玄幻故事生动形象地讲述了一个中华武林的真实故事\t啊不，是并查集。\n提到了几个要点：fa数组，find函数，together函数，路径压缩 等等\nfa数组 fa[i]​生动形象地记录了你的爹地是谁qwq\n是不是很直观、生动？\n咳咳，fa[i]表示第$i$个节点的父亲(也就是掌门人)的节点编号\nfind函数 你开始打电话，逐层查找你的上级、你上级的上级…………\n实现十分简单，只要不断访问fa[i]即可，直到 $fa[i]=i$​；\ntogether函数 两个门派经过昏天黑地的战斗后，决定合并…………因为人都打没了\n只要把find函数返回的值选择一个合并到另一个里即可\nfa[find(x)]=find(y); 路径压缩 故事最后一段\n为了防止储存集合所生成的树过高而采用的方法\n具体来说，就是每一次find时，将所访问到的所有节点都挂在根节点下。\n按秩合并 （达到和路径压缩几乎相同的结果，但是并不更优，还难以理解，放弃吧…………）\n记录每棵树的树高(根到叶子的最大边数)depi,两棵树合并的时候将dep较小的根挂在dep较大的根下面。\n当且仅当两棵树的dep相同时新树的树高为dep+1,否则为dep。\n那么dep=1的树有一个结点,dep=2的树至少有两个结点,dep=3的树只能至少由两个dep=2的树合并而来,所以至少有4个结点…\n所以按秩合并保证了树高不超过$\\log{n}$​,时间复杂度$O(n\\log{n})$​​\n贴份代码：\nint f[N], s[N]; // 取秩为集合大小 inline void init(int n) { for (int i = 1; i \u003c= n; ++i) f[i] = i, s[i] = 1; } int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } // 路径压缩 inline void merge(int x, int y) { // 按秩合并  x = find(x), y = find(y); if (x == y) return; if (s[x] \u003e s[y]) swap(x, y); f[x] = y, s[y] += s[x]; } 最后……………代码! surprise!!! 洛谷P3367 就是板子\n#include \u003ccstdio\u003econst int maxe = 10009; int n, m, fa[maxe]; inline int find(int x) //find函数和路径压缩的完美结合,递归思想 { return fa[x] == x ? x : fa[x] = find(fa[x]); } inline void together(int a, int b) //应该是最短的写法 { fa[find(a)] = find(b); } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) //初始化,最开始每个人都是一个门派  { fa[i] = i; } while (m--) { int a, b, c; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c); if (a == 1) together(b, c); else printf(\"%c\\n\", find(b) == find(c) ? 'Y' : 'N'); } return 0; } 带权并查集 ","categories":"","description":"","excerpt":"普通并查集 引子 脑洞蛮大的一个东西，自己还改了改\n​ 江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来 …","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":"","title":"并查集"},{"body":"","categories":"","description":"先进先出？\n","excerpt":"先进先出？\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/","tags":"","title":"栈"},{"body":"背包问题 01背包 引题： 原版： 有一个背包，可容纳重量为 $k$ 的物品。有 $n$ 个物品（每个物品只有一个），第 $i$ 个物品的重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。\n魔改版：\n你有 $n$ 项作业，但是你只有 $k$ 的时间，第 $i$ 项作业需 $val_i$ 个小时完成。但是，因为作业的内容、难度不同，对于每一项作业老师取得的快乐值也不同。\n比如：如果你完成了一道全班只有你才完成的数学难题，老师会很高兴，即使你没有把定义练习抄写1000000000遍，老师也不会批评你；然而，如果你只把 $1+1=2$ 这类的题做完了，而稍微难一点儿的题就不做，老师就会很生气，认为你很懒，而让你把定义再抄100000000000遍。\n问，在有限的时间内，如何使老师获得的快乐值最大？从而免去抄写\n心灵的震撼 我相信，每一个第一次接触dp的人都会为之而着迷，毕竟一种优美的暴力手段是每一个有着 $ak\\space IOI$ 的人所梦寐以求的。\ndp之所以比暴搜快，可以看做是因为记录了中间过程的权值，进而优化掉了DFS中很多重复的子树，也可以看做一种牺牲空间换取时间的做法。\ndp的核心思想就是从之前的状态推导当前状，进而在 $O(1\\sim n)$ 的时间内找到当前状态的解。\n也就是说，dp时无需考虑问题整体，而是化为一个个的状态，只需要关注某个状态如何从之前已经得到的状态中转移过来。\n使用dp时很多时候论证其正确性是一个费时费力还费脑子的工作，因此dp题目需要你有一定的经验、大胆的尝试和欧气(毕竟dp的样例一般都很水，可能一道题样例全过就得个 $30+$ 的分数也不是没有可能)，因为考试的时候没那么多时间，大多数dp代码都不长，建议有想法就直接写，搞出来后跑样例，然后再做调整。正常情况下，只要能过 $1+$ 个样例，基本上不会暴零。可以先写出一个局部解，然后再完善dp的状态转移方程。\n上面唠唠叨叨\ndp最重要的就是状态和转移。\n在01背包中，我们用 $dp[i][j]$ 表示在前 $i$ 件物品中选择，背包容量为 $j$ 时能装的最大价值。\n然后，思考这个式子： $$ dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+val[i]) $$ $max$ 表示求取的最大值。因为我们已经知道了前 $i-1$ 个物品在背包容量为 $a\\in[1,k]$ 时能装下的最大价值，因此对于第 $i$ 件物品，只有两种选择：\n 装(前提是 $w[i]\\le j$，毕竟得能装下才有讨论的必要) 不装 (你能把我怎样？)  若不选择第 $i$ 件物品，很简单，其在容量为 $j$ 的背包下最大价值 $=$ 从前 $i-1$ 件中选择的最大价值(反正不选第 $i$ 件，所以没有影响) $=\\space dp[i-1][j]$。\n若选择第 $i$ 件物品，则应在前 $i-1$ 个中选择后至少剩余 $w[i]$ 的背包空间，然后选择第 $i$ 个物品，我们就会获得它的价值 $val[i]$，因此总共获得价值为 $dp[i-1][j-w[i]]+val[i]$。\n易证，当物品相同时，大容量的背包装的总价值一定不小于小背包装的，因此只考虑最大的可能背包即可，不必遍历小背包。\n当我们把这张表填完的时候，$dp[n][k]$ (表示选择前 $n$ 个物品背包容量为 $k$ 时能装下的最大值)就是我们要求的最终答案。\n线性优化 我们发现了一个问题，上述01背包问题求解时，时间复杂度为 $O(nk)$，而空间复杂度也为 $O(nk)$。\n因为这玩意常数比较小，在 $nk\\le10^8$ 内都能跑过，但是，内存肯定不够用啊……人间疑惑\n可不可以优化一下啊，毕竟好不容易不TLE了要是再MLE可就要砸电脑了螺旋升天了，进而怀疑人生……\n好消息！好消息！好消息！空间可以优化！\n观察转移方程，我们实际上只用到了 $2\\times k$ 个值，其余的我们都不需要，所以，我们搞一个 int dp[2][k]好吗？\n当然可以！只要你调的出来，理论上确实可行，只要你不是每搞完一行整一个 O(k) 的复制就行\n下面，让我们再动脑子想一想，在缩小一下转移方程使用到的值，其实只有 $dp[i-1][a\\in[1,j]]$，大于 $j$ 的我们用不到！\n所以，我们能不能在一维数组上解决这个问题呢？\n当然可以！没得怕的\n只要我们从后往前遍历即可！即for(int i = k;i \u003e 0;i--)即可。\n因为，当我们遍历原二维数组第 $i$ 行时，现在数组中存储的就是原二维数组第 $i-1$ 行的值，并且即使大于 $j$ 的部分被更改，我们需要使用的小于等于$j$ 的部分仍旧是原第 $i-1$ 行的dp值，因此，状态转移方程魔改一下： $$ dp[j]=max(dp[j],dp[j-w[i]]+val[i]) $$ 体会到了人类脑洞之大\n我们的最终答案，就在跑完之后，存在 $dp[k]$ 的地方。\n注：\n 如果要 $dp[j] =$ 重量恰好为 $j$ 的最大价值，在DP前将 $dp$ 数组初始化为 $\\infty$ 即可。 如果有重量为负值（显然此时要求的是重量恰好为 $j$ 的最大价值），循环顺序要改为正序，且 $dp$ 的下标统一加一个足够大的数以保证全为正数！ 一维优化不能重构路径，但是二维数组可以通过一些办法(回溯，又称为逆推)求出咋装的。  完全背包 背包问题大多是从01背包的基础上演化而来，简言之就是01背包的增强版。\n01背包的问题魔改一下就是完全背包：\n我们还有一个背包，可容纳重量为 $k$ 的物品。有 $n$ 种物品（每种物品有无限多个），第 $i$ 种物品的重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。\n我们依然使用 $dp[i][j]$ 表示从前 $i$ 种物品中选择，背包容量为 $j$ 时能装的最大价值。\n然后，状态转移方程就变化了： $$ dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+val[i]) $$ 不难发现，对于第 $i$ 种物品，我们可以选择 $a\\in[0,\\frac{j}{w[i]}]$ 个。分为两类：\n 不选第 $i$ 种物品。 选第 $i$ 种物品 $a$ 个。  然后，这个问题又可以分为两步：\n 确定选还是不选 如果选，选几个  这时候，想一想dp的奥妙，即从已知推导出未知。\n不选很好解决，$dp[i-1][j]$ 就是不选第 $i$ 种的最大价值。\n那如果选呢？再回想dp数组的意义和01背包对于选物品的空间预留，可以得到 $dp[i][j-w[i]]+val[i]$ 这样的一个式子。我们只需要在可以选择第 $i$ 种的情况下留出 $w[i]$ 的空间来再装下一个第 $i$ 种物品即可。这样，我们无需知道第 $i$ 种物品应该选择几个，因为我们只需要在之前的最优解上进行状态转移即可，换言之我们只需要考虑多装一个是否更优，而不是遍历装几个更优，因为背包容量从小到大，能装下的个数也是从小到大。\n线性优化 和01背包一样，完全背包依旧时间复杂度 $O(nk)$，空间复杂度 $O(nk)$。\n那么，就会出现同样的问题。\n既然差不多，完全背包也能线性优化吗？\n**当然可以！**只不过需要进行一些调整，来适应新的状态转移方程。\n我们发现，新的状态转移方程依赖于 $dp[i][a\\in[0,j]]$ 而并不依赖于 $dp[i-1][a\\in[0,k]]$ 和 $dp[i][a\\in(j,k]]$，因此，我们需要改变遍历的顺序。\n上面我们已经理解了线性优化后 $dp[j]$ 在修改前表示 $dp[i-1][j]$，所以for(int i = 0;i \u003c k;i++)改为正序遍历即可先求出第 $i$ 行较小的 $j$ 进而推导出较大的 $j$，完成dp。这样，空间复杂度降为 $O(k)$。\n同01背包，一维优化不能重构路径，但二维可以。\n多重背包 同样，上来还是老问题：\n我们又有一个背包，可容纳重量为 $k$ 的物品。有 $n$ 中物品，第 $i$ 种物品有 $c[i]$个，每个重量为 $w[i]$，价值为 $val[i]$。求背包可容纳物品的最大价值。\n看，看，看，是不是和01背包又是差不多？\n所以，最简单的想法就是将每个物品拆成独立的个体，跑01背包，时间复杂度为 $O(k\\times\\sum_{i=1}^nc[i])$。\n但是，显然，太慢了！\n观察，多重背包与01背包最大的不同，就是有多个物品属性相同， 这也成为优化的入手点。\n先说一个题外话：人民币大家都知道吧，有$1$元的、$10$元的还有红色毛爷爷……那么，为什么不全用$1$元的？这样也可以表示任意的金额啊？\n但是，前几天刚出现了一个新闻，某男子用一麻袋硬币交房租被告上法庭……所以，体会到了红色毛爷爷的重要性。\n因此，我们的多重背包也可以借助这个思想，将 $c[i]$ 个物品划分成几组，从而能且仅能表示出所有 $a\\in[0,c[i]]$ 。\n问题来了，知道了为什么要分组，接下来就是怎么分组了。\n二进制拆分 我们先来看 $0\\sim19$ 的二进制表：\n   十进制 二进制     0 00000   1 00001   2 00010   3 00011   4 00100   5 00101   6 00110   7 00111   8 01000   9 01001   10 01010   11 01011   12 01100   13 01101   14 01110   15 01111   16 10000   17 10001   18 10010   19 10011    然后，我们发现，对于任意一个二进制数，均可以用不同的只有一位是 $1$ 的二进制数相加得到，如：\n$13$ = $(01101)_2$ = $(01000)_2+(00100)_2+(00001)_2$\n而这个规律翻译成十进制就是，对于数 $2^{k-1}\u003ca\\le2^k$ 一定可以用 $2^0,2^1,2^2,2^3,\\dots,2^{k-1}$ 和 $a-2^{k-1}$ 中的某几个数相加得到。这就构成了我们分组的依据。\n我们将 $c[i]$ 拆分成 $2^0,2^1,2^2,\\dots,2^{k-1},c[i]-a$，当成一共 $k$ 个物品，第 $x$ 组(个)物品的重量为 $第x组的个数\\times w[x]$，价值为 $第x组的个数\\times val[x]$。\n这样拆分之后，在跑01背包，即可将时间复杂度降至 $O(k\\times\\sum_{i=1}^n\\log{c[i]})$。\n混合背包 01、完全、多重背包三合一。大锅炖\n01背包当 $c[i]=1$，完全背包当 $c[i]=\\lfloor\\frac{k}{w[i]}\\rfloor$ 即可。\n多限制背包 物品有更多属性，对每种属性都有限制。\n把所有限制都加到状态里即可。\n分组背包 描述：有n件物品，分为若干组，现约束，在每组物品里最多取一件物品放入背包，每件物品的重量确定，价值确定，背包容量确定，求在不超过背包容量的情况下，可以存放的最大价值。\n$w[i][j]$ 表示第 $i$ 组第 $j$ 件物品的重量，$val[i][j]$ 表示第 $i$ 组第 $j$ 件物品的价值，$dp[a][b]$ 表示在前 $a$ 组中选择重量不大于 $b$ 的最大价值。\n对于任意一组物品，共计两类状态：\n 一个都不选 选择第 $i\\in[1,len]$ 个  因此，在01背包的基础上进行嵌套循环，每次遍历整组，求出最优解即可。\n线性空间优化见上文。\n背包方案计数 把所有的取 $max$ 都改成求和即可。\n注意：多重背包不能用二进制拆分优化了，因为同样的数量拆分方式不唯一。\n依赖性背包 依赖关系只有一层：把每个“主件”当做一个背包，然后将各背包合并（也是树形背包的基本思路）。\n无循环依赖（树形背包）：树形DP。\n有循环依赖：Tarjan+缩点 + 树形DP。\n请在相应章节查看。\n","categories":"","description":"背上你的小书包啊……\n","excerpt":"背上你的小书包啊……\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","tags":"","title":"背包问题"},{"body":"递推 ","categories":"","description":"从前有座山，山上有座庙，庙里有个老和尚，老和尚在给小和尚讲故事，讲的是：从前有座山，山上有座庙，庙里有个老和尚…… \n","excerpt":"从前有座山，山上有座庙，庙里有个老和尚，老和尚在给小和尚讲故事，讲的是：从前有座山，山上有座庙，庙里有个老和尚…… \n","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E9%80%92%E5%BD%92%E9%80%92%E6%8E%A8/","tags":"","title":"递推和递归"},{"body":"题海茫茫，回头是岸。\n","categories":"","description":"","excerpt":"题海茫茫，回头是岸。\n","ref":"/oiblogs/ans%E9%A2%98%E8%A7%A3/","tags":"","title":"题解"},{"body":"拓扑排序 一篇博文\n引子 下面让我来看一看拓扑序是什么，又有啥子用。\n众所周知，万事都要讲究先来后到。比如，你对一个婴儿进行早教，你很自信、很闪耀，觉得此孩儿定是天降奇才，跳过了万水千山，连话都不会说，直接交他拓扑排序，为以后发扬光大OI事业而打下坚实的基础。然后，一段时间以后，你忽然发现，你教授完一万字的长篇大论然而并没有一点用处，甚至人家一眼都没看你。所以，你十分灰心，感受到了生活的无情，决定放下倔强，从头教起。你潜心研究，发现有一些知识需要在某些知识已经掌握的情况之下才可以学习；所以，你编写了一个程序，给出学习各种知识的先后顺序。\n为啥是图论 看上面的段子，脑海中浮现出各种问号……\n这东西为啥子是图论嘞？\n我们先搞一下啥是DAG(有向无环图)：\n一个有向图,且不存在环。 多么简洁明了\n这时候，考虑将边 $u\\rightarrow{v}$​ 具体为”做 $v$ 之前要先做 $u$​​ ”，那么拓扑排序能求出每件事应该在什么时候做，也就是说满足每件事的前置事件都做完后它才能开始做的一种安排。\n拓扑序不是唯一的,因为有些点之间不存在拓扑关系。\n比如，上图中A和E、B和D等就没有拓扑关系。\n建图到此结束。\nBFS款 入度：指向某个点的有向边条数。\n我们发现，对于任意一个DAG，总有入度为$0$的节点。完成这个节点无需依赖其他任何节点的完成情况。\n因此，我们维护一个队列(其实栈也不是不行)，队列中包含所有入度为$0$的节点。\n对于每一个队列中节点，删去其所有初度，并将删边后入度为$0$​的节点加入队列。\n如需按照字典序大小求拓扑序，改为使用优先队列即可(即优先访问字典序大/小的节点)。\n记录已经遍历的节点数，若队列为空并且已经遍历的节点数小于总节点数，则说明存在环。\n如上图，当出现环时，删除一定数量的节点和边后，出现所有节点入度均大于$0$​的情况，即队列为空。\n两种算法复杂度均为$O(n+m)$。\nPOJ2367 外加一点补充\n#include \u003ccstdio\u003e#include \u003cqueue\u003e#include \u003cvector\u003eusing std::vector; const int maxe = 109; //最大节点个数 int len, in[maxe], cnt; //len总节点数,in[i]第i号节点的入度,cnt已经遍历的节点个数 vector\u003cint\u003e next[maxe]; //邻接链表存图 std::priority_queue\u003cint, vector\u003cint\u003e, std::greater\u003cint\u003e \u003e running; //如无需按字典序输出,请改用queue;注意两个'\u003e'中间有一个空格,看好是小顶堆还是大顶堆 int main() { scanf(\"%d\", \u0026len); for (int i = 1; i \u003c= len; i++) { int a; while (1) { scanf(\"%d\", \u0026a); if (!a) break; next[i].push_back(a); in[a]++; //每有一条指向节点的边,入度+1  } } for (int i = 1; i \u003c= len; i++) { if (in[i] == 0) //查找所有入度为0的节点  running.push(i); } while (!running.empty()) { int top = running.top(); running.pop(); printf(\"%d \", top); cnt++; //已经遍历的节点数+1  int n = next[top].size(); for (int i = 0; i \u003c n; i++) //遍历所有出度,进行删边操作  { int now = next[top][i]; in[now]--; if (!in[now]) //如果删边后入度为0,则加入队列  running.push(now); } } if (cnt != len) //如果以遍历节点数小于总节点数,说明有环  printf(\"error\\n\"); return 0; } DFS款 选定一个节点，递归完成他的入度。\n对于每个节点循环。\n还是学上面那个吧\n","categories":"","description":"先来后到？\n","excerpt":"先来后到？\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","tags":"","title":"拓扑排序"},{"body":"离散化 好高深的鸭子\n其实，用STL水就可以了\n离……散化？ 离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。即在不改变数据相对大小的条件下，对数据进行相应的缩小。通俗地讲就是当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，而影响最终结果的只有元素之间的相对大小关系时，我们可以将原来的数据按照从大到小编号来处理问题，即离散化。\n好了，上面的多无聊\n很简单，就是如果你只需要 $k$ 个数，但是可能存在 $n$ 种情况，你开不下下标为 $n$ 的数组，因此你丢出了离散化来解决这个问题。\n所以……实现？ 如果你不嫌累的话，你大可以学习各种各样奇奇怪怪的离散化的方法(包括但不限于Hash、排序)。\n但是，这种非常常见的东西C++ STL里面肯定有啊。\n所以，介绍几个：\nmap  ","categories":"","description":"要搞事……\n","excerpt":"要搞事……\n","ref":"/oiblogs/others%E6%9D%82%E9%A1%B9/%E7%A6%BB%E6%95%A3%E5%8C%96/","tags":"","title":"离散化"},{"body":"质数 本标题下所有数 $x\\in N^*$ 。\n单个质数的判定 思想 枚举 $i\\in{{1\\sim\\sqrt{P}}}$​​ ，判断$P\\mod{i}$​​​​是否为$0$​即可。\n若数 $P=p_1*p_2$​ 并且 $p_2\u003e\\sqrt{P}$​ ​​，则 $p_1\u003c\\sqrt{P}$​ ,所以只需要枚举 $i$​ 到 $i\u003c=\\sqrt{P}$​ 。\n代码 bool prime(int n) { int len = sqrt(n);//求i的遍历范围  for (int i = 2; i \u003c= len; i++) if (!(n % i))//如果i是n的约数，说明n不是质数，返回false  return false; return true;//n除了1和n以外没有别的约数，证明n是质数，返回true } 时间复杂度 $O(\\sqrt{n})$。\n单个数分解质因数 想法和上面的一样，只不过找到一个因数就循环除他罢辽。\nlist\u003cint\u003e prime(int n) { list\u003cint\u003e result; int len = sqrt(n); //求i的遍历范围  for (int i = 2; i \u003c= len; i++) { if (N % i == 0) { // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。  while (N % i == 0) N /= i; result.push_back(i); } } if (N != 1) { // 说明再经过操作之后 N 留下了一个素数  result.push_back(N) } } 范围内所有质数的判定 纯暴力 就把上面那个套个循环，复杂度 $O(n\\sqrt n)$。\n埃氏筛 从 $2$ 开始，不断寻找没有被标记的，并把它的倍数全部标记，复杂度 $O(n\\log\\log n)$。\n但是，我们注意到，某一些合数被标记了不止一次，因此仍有优化空间。\n欧拉筛 ","categories":"","description":"杂七杂八……\n","excerpt":"杂七杂八……\n","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E8%B4%A8%E6%95%B0%E5%90%88%E6%95%B0%E7%BA%A6%E6%95%B0%E5%80%8D%E6%95%B0/","tags":"","title":"质数、合数、约数"},{"body":"","categories":"","description":"当你查找通讯录的时候，你一定是按照A、B、C、D……去找的，因为：快！\n","excerpt":"当你查找通讯录的时候，你一定是按照A、B、C、D……去找的，因为：快！\n","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%88%86%E6%B2%BB%E4%BA%8C%E5%88%86/","tags":"","title":"分治（二分）"},{"body":"本章所提到的思想，都是各种更高级算法的思想基础，对于以后算法的学习与应用大有好处。\n这些内容可以让初学者对 OI 的一些思想有初步的认识；另一方面，本章介绍的大部分算法还会在以后的进阶内容中得到运用。\n","categories":"","description":"","excerpt":"本章所提到的思想，都是各种更高级算法的思想基础，对于以后算法的学习与应用大有好处。\n这些内容可以让初学者对 OI 的一些思想有初步的认识；另 …","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/","tags":"","title":"基本思想"},{"body":"线性dp 最基本的dp和dp简介 一种优美的暴力 动态规划可以看做在最优化问题和计数问题中对暴力搜索的优化。\n在暴力搜索中，我们要枚举每一步决策，枚举所有的方案。\n但在多数问题中，暴力搜索其实会做大量重复工作，重复计算大量中间结果。\n动态规划就是把这些中间结果用dp数组记录下来，以便后续利用。\n最基本的状态和转移方程的设计比较容易，在NOIP题目中一般占分 $30\\sim60$。\n最基本的方程的设计并没有特别的技巧。一般来说，\n 动态规划问题的“三大要素”：状态、转移、边界。 题目中给的条件都可以加入状态中，题目要求最优化的值就是DP值。 转移方程往往根据最后一步决策来设计。  线性dp 状态均沿一个方向转移的dp。\n例如最基本的模型——数字三角形和最长上升子序列(LIS)都属于线性dp。\n[洛谷P1216 [USACO1.5][IOI1994] 数字三角形 Number Triangles](https://www.luogu.com.cn/problem/P1216)\n$dp[i][j]$表示以第 $i$ 行第 $j$ 列为终点的最大数字和，转移方程为 $dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+val[i][j]$。\nOpenjudge 2.6 1759 最长上升子序列\n一会儿详细的说。\n几种优化的方式 因为dp要对于题目而设计转移方程，因此有一些优化方式仅能用例题去表示。\n但是，强烈建议能想到dp的题先搞出来最基本的，然后再优化，便于对拍和防止暴零。\n无优化 以LIS为例子。\n求最长上升子序列和最长不降子序列(注意，是子序列以及不降表示可以相等;对于固定的数组，虽然LIS序列不一定唯一，但LIS的长度是唯一的)。\n我们用 $dp[i]$ 表示以第 $i$ 位结尾的LIS长度。\n转移时每次都向前找比它小的数和比它大的数的位置，将第一个比它大的替换掉。这样操作虽然LIS序列的具体数字可能会变，但是很明显LIS长度还是不变的，因为只是把数替换掉了，并没有改变增加或者减少长度。\n因此，转移方程为：\nif (num[i - 1] \u003c num[i]) dp[i] = dp[i - 1] + 1; else { int big = 2e9, ji = -1; for (int j = 1; j \u003c i; j++) { if (num[j] \u003c big \u0026\u0026 num[j] \u003e= num[i]) { big = num[j]; ji = j; } } dp[i] = ji == -1 ? 1 : dp[ji]; } 比较复杂\n减少多余状态 打一个恰当的比方，当你的 $dp$ 状态有$4$个，但是其中一个可以由剩下的$3$个推算得来，则这个状态就可以省略(优化掉)。\n改变状态设计 通俗一点，就是换一个dp的思路。\n前（后）缀和优化DP 背包问题 背包问题是一类特殊的线性DP问题。其模型应用极为广泛，故单独叙述。\n","categories":"","description":"在一条线上暴力？\n","excerpt":"在一条线上暴力？\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7dp/","tags":"","title":"线性dp"},{"body":"","categories":"","description":"这才是正经八本的排队嘛！\n","excerpt":"这才是正经八本的排队嘛！\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/","tags":"","title":"队列"},{"body":"每天跑断腿儿。\n","categories":"","description":"","excerpt":"每天跑断腿儿。\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/","tags":"","title":"图论"},{"body":"差分数组 定义 对于第$i$位，记录第$i$位减第$i-1$位的差值。\n例子：\n   下标 0 1 2 3 4 5 6     原数组 0 6 9 5 4 7 3   差分数组 0 +6 +3 -4 -1 +3 -4    用途 快速进行区间修改操作。\n注意! 只适用于可被抵消贡献的运算中，如$+/-/\\and$​(加、减、异或)等。\n若将原数组$[l,r]$区间内加$val$，则相当于将差分数组第$l$位加$val$，第$r+1$位减去$val$(将贡献抵消)。\n注意! 是第$r+1$位，而不是第$r$​位!!! 经常和维和区间和的数据结构一起使用。(树状数组等)\n","categories":"","description":"区间修改？不在话下！\n","excerpt":"区间修改？不在话下！\n","ref":"/oiblogs/others%E6%9D%82%E9%A1%B9/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","tags":"","title":"差分数组"},{"body":"最小生成树 问题描述 给出一个有$n$个节点，$m$条边的无向图，从中选取边权之和最小(大)的$n-1$条边，使得图上任意两个顶点有且只有唯一的一条路径可以互相到达。\n例子 如上图，其最小生成树为： 红色部分 和 注意 最小生成树可能不唯一(边权相等)\n暴力 枚举每一种可能的情况，计算最小值(因复杂度过高，不再赘述)。\nPrim算法 时间复杂度：$O(nm)\\sim O(m\\log{n})$​ 数据结构优化\n一篇比较详细的博文\n以点为核心，每次选择当前已选中的点连接未选中的点的边中权值最小的一个，将这个点加入已选中的点集，并用和这个点连接的边更新未选中的点的距离。\n例子 盗图很开心\n洛谷P3366 其实就是板子\n#include \u003ccstdio\u003econst int maxe = 6000; //n的最大值 int n, m, head[maxe], cnt; //n个点,m条边,head[i]表示已i为端点最后读入的一条边的编号,已经读入cnt条边 bool vis[maxe]; //vis[i]标记i节点是否在最小生成树点集中 struct node { int value, last, sign; //value表示边权,last表示同一起点的上一条读入的边的编号,sign表示当前节点编号 } edge[400009]; //m最大值*2 inline void add_edge(int start, int end, int value) //链式前向星 { edge[++cnt].value = value; edge[cnt].sign = end; edge[cnt].last = head[start]; head[start] = cnt; return; } inline int prim() { int dis[maxe], ans = -1e9; //dis[i]表示连接未加入点集的i号节点和点集中任意点最短路径长,ans = -1e9抵消选择第一个点溢出  for (int i = 1; i \u003c= n; i++) { dis[i] = 2e9; //初始化dis数组  } int k = 1, min; //k记录所选择的点的编号,min记录最小值,k初始值为第一个加入点集的点的编号  vis[1] = 1; //将第一个点加入点集  for (int i = 0; i \u003c n; i++) //循环n次,将所有点加入点集  { min = 1e9; //别忘了qwq,注意小于dis初始者,判断是否无法建树  for (int j = 1; j \u003c= n; j++) //暴力搜索最小点,可用堆/平衡树(优先队列、set等)优化  { if (!vis[j] \u0026\u0026 dis[j] \u003c min) { min = dis[j]; k = j; } } if (min == 1e9 \u0026\u0026 k != 1) //除第一个点外,如果没有未加入点集的点有连接且点集中小于n个点,证明有点无法连同  { return 0; } ans += min; vis[k] = 1; for (int i = head[k]; i; i = edge[i].last) //用新加入的点更新dis数组  { if (!vis[edge[i].sign] \u0026\u0026 dis[edge[i].sign] \u003e edge[i].value) { dis[edge[i].sign] = edge[i].value; } } } return ans; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 0; i \u003c m; i++) { int a, b, value; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026value); add_edge(a, b, value); //无向边,任意端点可作为起止点  add_edge(b, a, value); } int ans = prim(); if (ans) printf(\"%d\", ans); else printf(\"orz\");//无法连同所有点  return 0; } Kruskal算法 时间复杂度： $O(m\\log{m})$\n想法比较简单、易懂。\n将所有边按权值从小到大排序，优先选取权值较小的边，判断两个端点是否在同一个集合中。如果在同一集合中，则跳过这条边，遍历下一条；如果不再同一集合中，则将ans加上边权并将两个点所在的集合合并。\n涉及到判断两个点是否在同一集合中，需要引入并查集。\n洛谷P3366 其实就是板子\n#include \u003ccstdio\u003e#include \u003calgorithm\u003eint n, m, fa[6000], ans, cnt; //n个节点,m条边,已经选择cnt条边 struct edge { int a, b, value; } edges[200009]; //有一条端点是a和b,权重为value的边 inline bool cmp(edge a, edge b) //比较函数 { return a.value \u003c b.value; } inline int find(int x) //并查集 { return fa[x] == x ? x : fa[x] = find(fa[x]); } inline void together(int x, int y) { x = find(x); y = find(y); fa[x] = y; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { fa[i] = i; } for (int i = 0; i \u003c m; i++) { scanf(\"%d%d%d\", \u0026edges[i].a, \u0026edges[i].b, \u0026edges[i].value); } std::sort(edges, edges + m, cmp); //按边权排序  for (int i = 0; i \u003c m; i++) { if (find(edges[i].a) != find(edges[i].b)) //如果两个端点不再同一集合  { ans += edges[i].value; //选中这条边  cnt++; together(edges[i].a, edges[i].b); //合并两个集合  } if (cnt == n) //最小生成树边数等于总节点数-1  break; } if (cnt == n - 1) //最小生成树边数等于总节点数-1  printf(\"%d\", ans); else printf(\"orz\"); return 0; } 总结 两种算法均用到贪心的思想。\nPrim侧重于点，适合稠密图；Kruskal侧重于边，适合稀疏图；但二者优化后差距并不大，推荐Kruskal，易理解不费手还不容易出奇奇怪怪的问题。(复杂度中可以看出)\n","categories":"","description":"我们又开始种树了……\n","excerpt":"我们又开始种树了……\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/","tags":"","title":"最小生成树"},{"body":"KMP 入门第一发 相信，很多人入门的第一个算法(除去贪心等基本思想)，所以，先来略略领会一下dp的奥妙和人类的脑洞叭。\n字符串匹配问题： 一类在一个字符串中查找其他字符串出现情况的问题。称被匹配的串为主串；称在主串中寻找匹配位置的串为模式串。\n其按模式串个数分为单模匹配和多模匹配问题。而KMP是一种利用 LBorder 来高效解决单模匹配的算法。\n单模匹配问题：给定两个串 $n$ 和 $m$ ，求 $m$在 $n$ 中出现的所有位置。\n字符串 $s$ 的公共前后缀（即：$s[i]=s[len-i]$）称作Border。空串与原串也是 Border。\n非原串的最长的 Border 称作 LBorder (Longest Border)。\nLBorder 的性质使得 KMP 算法在匹配失败时能够直接按 LBorder 将主串与模式串重新对齐并继续尝试匹配，从而有效避免了暴力做法中盲目试错的过程。\n预处理 为模式串建立 $next$ 数组，$next[i]$ 表示当模式串匹配到第 $i$ 位失配时应该从哪一位开始匹配。\n注意，$next[0]$ 和 $next[1]$ 不存在Border(一共长度没有 $2$，上哪来的两个子串？)，因此根据其意义规定为 $next[0]=next[1]=0$，在这两位失配时均从头开始匹配。\n而构建 $next$ 数组，运用了一点dp的思想，即尽可能的使用现有的去推导已知的。\n上图演示：当我们求 $next[j+1]$ 时，已经知道 $next[0]\\sim next[j]$ 的值。\n 首先，我们判断 $j+1=k$，若成立则 $next[j+1]=next[j]+1$ 并退出，若不成立执行第 $2$ 步。 再次判断 $j+1=h$，若成立则 $next[j+1]=next[k]+1$ 并退出，若不成立执行第 $3$ 步。 接着判断……  那么，问题来了，问什么我们这样做是对的呢？(这题我A了，但是为什么？)\n看上图，方块表示对应位置的字符，每条颜色对应的横线是相等的子串(其实就是之前求出的LBonder)。\n  因为 $A_1=A_2$，因此 $next[j]=k$。如果 $j=k$，则 $next[j+1]$ 应该指向 $k+1$ 位(LBonder的长度为 $A_1+第k位$)。\n  若上面的没匹配到，则因为 $A_1=A_2\\space\u0026\\space b_1=b_2$，我们可以推导出 $b_1=b_3$，这样，我们又重复了上面的那个问题，所以一样的方法再做一遍即可。\n  我们推导可知， $c_1=c_2=c_3=c_4$，所以继续……\n  下面，我们上代码！\n因为通常起始位置可能是下标 $0$ 或者是下标 $1$，构建的时候可以目标第 $j$ 位或者第 $j+1$ 位；因此，经过组合数的计算，我们一共有 $4$ 种代码。\n从 $0$ 开始目标 $j$ 位：\ninline void get_next(char *in, int *next) { int len = strlen(in); next[0] = next[1] = 0; for (int i = 2; i \u003c= len; i++) { int now = next[i - 1]; while (now \u0026\u0026 in[now] != in[i - 1]) now = next[now]; next[i] = in[i - 1] == in[now] ? now + 1 : 0; } } 从 $0$ 开始目标 $j+1$ 位 ：\ninline void get_next(char *in, int *next) { int len = strlen(in); next[0] = next[1] = 0; for (int i = 1; i \u003c len; i++) { int now = next[i]; while (now \u0026\u0026 in[now] != in[i]) now = next[now]; next[i + 1] = in[i] == in[now] ? now + 1 : 0; } } 从 $1$ 开始目标 $j$ 位：\ninline void get_next(char *in, int *next) { int len = strlen(in); next[1] = next[2] = 1; for (int i = 3; i \u003c= len; i++) { int now = next[i - 1]; while (now \u003e 1 \u0026\u0026 in[now] != in[i - 1]) now = next[now]; next[i] = in[i - 1] == in[now] ? now + 1 : 1; } } 从 $1$ 开始目标 $j+1$ 位：\ninline void get_next(char *in, int *next) { int len = strlen(in); next[1] = next[2] = 1; for (int i = 2; i \u003c len; i++) { int now = next[i]; while (now \u003e 1 \u0026\u0026 in[now] != in[i]) now = next[now]; next[i + 1] = in[i] == in[now] ? now + 1 : 1; } } 开始匹配 而接下来的匹配就很好搞了，只要一失配就跳next即可。这样，可以做到主串的 $i$ 不会退，提高了效率。\n洛谷 P3375 【模板】KMP字符串匹配\n#include \u003ccstdio\u003e#include \u003ccstring\u003econst int maxe = 1e6 + 9; char a[maxe], b[maxe]; int nxt[maxe], na, nb; inline void get_next(char *in, int *next) { int len = strlen(in); next[0] = next[1] = 0; for (int i = 2; i \u003c= len; i++) { int now = next[i - 1]; while (now \u0026\u0026 in[now] != in[i - 1]) now = next[now]; next[i] = in[i - 1] == in[now] ? now + 1 : 0; } } int main() { scanf(\"%s%s\", a, b); na = strlen(a); nb = strlen(b); get_next(b, nxt); for (int i = 0, j = 0; i \u003c na; i++) { while (j \u0026\u0026 b[j] != a[i]) //不断失配跳转  { j = nxt[j]; } if (b[j] == a[i]) j++; if (j == nb) { printf(\"%d\\n\", i - j + 2); } } for (int i = 1; i \u003c= nb; i++) { printf(\"%d \", nxt[i]); } return 0; } 字符串最小循环节 证明：字符串最小循环节 = 字符串长度 - LBonder(尾部next数组)\n假设字符串 $a$ 是其子串 $b$ 循环 $k$ 次在加一个 $b$ 的前缀 $d$ 得到，$a$ 串的LBonder长 $x$，则我们思考一个问题：\n前 $k-1$ 个 $b$ 加一个 $d$ 等于后 $k-1$ 个 $b$ 加一个 $d$。举个栗子：\n   a a b c a b c a b     b a b c        前 a b c a b      后    a b c a b    我们发现，前 $k-1$ 个 $b$ 加一个 $d$ 等于后 $k-1$ 个 $b$ 加一个 $d$ 等于 LBonder！\n所以，$b$ 的长度就是(看上表) $a$ 串的长度 - 后 $k-1$ 个 $b$ 加一个 $d$ 的长度 = $a$ 的最小循环节\n所以，字符串最小循环节 = 字符串长度 - LBonder(尾部next数组)。\n","categories":"","description":"","excerpt":"KMP 入门第一发 相信，很多人入门的第一个算法(除去贪心等基本思想)，所以，先来略略领会一下dp的奥妙和人类的脑洞叭。\n字符串匹配问题：  …","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/kmp/","tags":"","title":""},{"body":"","categories":"","description":"一群人，咋整？当然是分成一组一组的。就比如，你的学校分为12个班级，你的班级分为4个小组……\n","excerpt":"一群人，咋整？当然是分成一组一组的。就比如，你的学校分为12个班级，你的班级分为4个小组……\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%88%86%E5%9D%97/","tags":"","title":"分块"},{"body":"","categories":"","description":"做人不可过于贪心，但是，做题可以啊！只要你保证你的贪心是对的（切忌人傻钱多，偷鸡不成蚀把米）。\n","excerpt":"做人不可过于贪心，但是，做题可以啊！只要你保证你的贪心是对的（切忌人傻钱多，偷鸡不成蚀把米）。\n","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83/","tags":"","title":"贪心"},{"body":"位运算 概述 现代计算机中所有的数据均以二进制的形式存储在设备中，即 $0$、$1$ 两种状态计。计算机对二进制数据进行的运算( $+$、$-$、$*$、$/$ )都是位运算，即将符号位共同参与运算的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。\n基本的位运算共 $6$ 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。通俗叫法会去掉“按位”，即与、或、异或、取反、左移和右移。\n其中，按位与、按位或、按位异或是将两个整数作为二进制数，对二进制表示中的每一位逐一运算；按位取反、左移和右移是对于某一个整数作为二进制数，对二进制表示中的每一位逐一运算。\n在位运算时，若两个整数的二进制位数不同，则在位数较少的前面补 $0$ 即可。\n整数二进制表 这是一张 $0\\sim31$ 的 $十进制\\longleftrightarrow二进制$ 对照表。\n二进制这个东西可以手推，但是比较麻烦，这张表在位运算的学习和实际应用中很方便比较并找到规律。\n   十进制 二进制     0 00000   1 00001   2 00010   3 00011   4 00100   5 00101   6 00110   7 00111   8 01000   9 01001   10 01010   11 01011   12 01100   13 01101   14 01110   15 01111   16 10000   17 10001   18 10010   19 10011   20 10100   21 10101   22 10110   23 10111   24 11000   25 11001   26 11010   27 11011   28 11100   29 11101   30 11110   31 11111    与 “与”，就是和的意思。定义如下：\n   C++运算符 数学符号 意义(咋算的)     \u0026 $\u0026\\space、\\operatorname{and}$ 均为 $1$，则结果为 $1$；任意一个是 $0$，结果为 $0$。    其对应的结果如下表：\n   数A第 $i$ 位 数B第 $i$ 位 结果     $1$ $1$ $1$   $1$ $0$ $0$   $0$ $1$ $0$   $0$ $0$ $0$    lowbit 正确的使用与运算(再加上一点技巧)，可以求出某一个数二进制下最低位的 $1$ 的位置。详情请参见树状数组。\n或 “或”，即或者。定义：\n   C++运算符 数学符号 意义(咋算的)     | $\\mid\\space、\\operatorname{or}$ 均为 $0$，则结果为 $0$；任意一个是 $1$，结果为 $1$。    其对应的结果如下表：\n   数A第 $i$ 位 数B第 $i$ 位 结果     $1$ $1$ $1$   $1$ $0$ $1$   $0$ $1$ $1$   $0$ $0$ $0$    异或 “异或”，大概就是变异的“或”吧。\n   C++运算符 数学符号 意义(咋算的)     ^ $\\oplus\\space、\\operatorname{xor}$ 均为 $0$ 或均为 $1$，结果为 $0$；两个不同(任意一个是 $1$，另一个是 $0$)，结果为 $1$。    其对应的结果如下表：\n   数A第 $i$ 位 数B第 $i$ 位 结果     $1$ $1$ $0$   $1$ $0$ $1$   $0$ $1$ $1$   $0$ $0$ $0$    异或与加法 一个定理：$a\\oplus{b}\\le{a+b}$\n证明：\n我们发现，位运算不进位；而加法运算当两个位都是 $1$ 时会进位。因此，观察上表，异或运算的得数是加法运算进位后剩余的数字。\n因此，在加法不进位时，$a\\oplus{b}={a+b}$；加法进位时，$a\\oplus{b}\u003c{a+b}$。\n取反 “取反”，顾名思义，就是 $0$ 变 $1$；\n左移 右移 ","categories":"","description":"深·恶·痛·绝！不是人脑干的事儿……\n","excerpt":"深·恶·痛·绝！不是人脑干的事儿……\n","ref":"/oiblogs/others%E6%9D%82%E9%A1%B9/%E4%BD%8D%E8%BF%90%E7%AE%97/","tags":"","title":"位运算"},{"body":"最短路径 是个啥 这种问题恰如其名，问如何走才能用最小的代价达到目的。(人生哲学)\n给你一张有边权的图(无权图可看做所有边边权均为1；无向图可将所有边拆分成两条有向边)，求$i$节点到$j$​节点的最短路径。\n直接上算法。\nDFS BFS就涉及到其他算法了。\n只能求解单源单尽~~(自创)~~最短路(固定起点和终点)并且通常情况下过于暴力。\n想法很简单，遍历两点之间的所有路径，选择最短的那条。\n#include \u003ccstdio\u003e#include \u003cvector\u003econst int maxe = 1e4 + 9; struct node { int next, val; }; std::vector\u003cnode\u003e edge[maxe]; int len, m, ans = 2e9, sta, end; bool ji[maxe]; inline void dfs(int now, int val) { if (val \u003e= ans || now == end) //结束条件和一点点剪枝  { ans = ans \u003e val ? val : ans; return; } int n = edge[now].size(); ji[now] = 1; //记录访问过的节点,防止环  for (int i = 0; i \u003c n; i++) { if (ji[edge[now][i].next]) //如果出现环,终止  continue; dfs(edge[now][i].next, edge[now][i].val + val); //继续递归  } ji[now] = 0; //访问归零 } int main() { scanf(\"%d%d%d%d\", \u0026len, \u0026m, \u0026sta, \u0026end); for (int i = 0; i \u003c m; i++) { int a, b, v; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026v); edge[a].push_back(node{b, v}); } dfs(sta, 0); printf(\"%d\", ans); return 0; } Floyd(弗洛伊德)算法 多源最短路(任意起止点)算法，时间复杂度 $O(n^3)$​，空间复杂度 $O(n^2)$​​。\n适用于具有正或负边缘权重，但**没有负周期(**负环)的加权图中。在稠密图中效率较高。\n运用dp思想，最开始只允许经过1号顶点进行中转，接下来只允许经过1号和2号顶点进行中转……允许经过$1\\sim n$​号所有顶点进行中转，来不断动态更新任意两点之间的最短路程。\ndp[i][j]表示从 $i$ 号节点到 $j$ 号节点的最短路径长度。\n 首先构建邻接矩阵(存图)，假如现在只允许经过1号结点，求任意两点间的最短路程，很显然  $$ dp[i][j]=\\min{dp[i][j],dp[i][1]+dp[1][j]} $$\n接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短距离，在已经实现了从 $i$ 号顶点到 $j$ 号顶点只经过$1$号节点的最短路程的前提下，现在再插入第$2$号结点，来更新更短路径，故只需在步骤1求得的基础上求 $$ dp[i][j]=\\min{dp[i][j],dp[i][2]+dp[2][j]} $$ $n$次更新后，表示依次插入了1号，2号……n号结点，最后求得的dp[i][j]是从 $i$ 号顶点到 $j$​ 号顶点只经过前 $n$ 号点的最短路程。  如需要记录详细路径，可使用另外一个二维数组存贮中转节点。\n#include \u003ccstdio\u003e#include \u003calgorithm\u003eusing std::min; const int maxe = 3000, INF = 1000000009; int n, m, dp[maxe][maxe], pot[maxe][maxe]; //如不需记录详细路径，不用pot inline void pr_dis(int dp[maxe][maxe]) //最短路径输出 { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { if (dp[i][j] == INF) printf(\"INF \"); else printf(\"%d \", dp[i][j]); } printf(\"\\n\"); } } inline void pr_way(int sta, int end) //递归重建路径 { if (pot[sta][end] == 0) //若有边连接,则终止递归  return; pr_way(sta, pot[sta][end]); //递归输出左侧  printf(\"%d \", pot[sta][end]); //输出本位  pr_way(pot[sta][end], end); //递归输出右侧 } int main() { scanf(\"%d%d\", \u0026n, \u0026m); int sta; scanf(\"%d\", \u0026sta); for (int i = 1; i \u003c= n; i++) //初始化  { for (int j = 1; j \u003c= n; j++) { dp[i][j] = i == j ? 0 : INF; } } for (int i = 0; i \u003c m; i++) { int a, b, v; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026v); dp[a][b] = min(dp[a][b], v); //判断重边  } for (int k = 1; k \u003c= n; k++) { for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { if (dp[i][j] \u003e dp[i][k] + dp[k][j]) { dp[i][j] = dp[i][k] + dp[k][j]; pot[i][j] = k; //更新节点记录  } } } } for (int i = 0; i \u003c n; i++) //输出  { for (int j = 0; j \u003c n; j++) { printf(\"\\n%d %d : \", i + 1, j + 1); pr_way(i + 1, j + 1); } } printf(\"\\n\\n\"); pr_dis(dp); //输出  return 0; } Dijkstra算法 用于求解非负权图的单源最短路径。\n运用贪心思想，时间复杂度 $O(n^2)$​​​ 或优化后 $O(n\\log{n})$​​，空间复杂度 运行空间 $O(n)$ 和存图​​ $O(m)$​。\n用 $dis[i]$ 存贮从起始节点到第 $i$ 号节点的相对最短路径长度，并标记已经确定最短路径的顶点。\n 初始化：设起始节点编号为 $k$，则 $dis[k]=0$，$i$ 与 $k$ 相连则 $dis[i]=边权$，其余的 $dis[j]=\\infty$。 松弛：在 $dis$ 数组中寻找未确定最短路径中 $dis[i]$ 最小，将 $i$ 加入已确定的顶点集合，并用其连接的边尝试使周围节点的 $dis$ 更小。(若存在负权，则有可能存在走负权边将以确定节点的最短路径变更小的可能，因此算法失效)  例子：\n最暴力的code:\n#include \u003ccstdio\u003e#include \u003cvector\u003econst int maxe = 1e5 + 9, INF = 2147483647; struct node //邻接链表存图 { int next, val; }; std::vector\u003cnode\u003e edges[maxe]; int n, m, sta, dis[maxe]; bool ji[maxe]; //记录是否已经确定答案 inline int lowest() //查找未加入点集中最小的dis { int ans, lowt = INF; for (int i = 1; i \u003c= n; i++) { if (!ji[i] \u0026\u0026 dis[i] \u003c lowt) { lowt = dis[i]; ans = i; } } return ans; } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026sta); for (int i = 1; i \u003c= n; i++) //初始化  { dis[i] = INF; } for (int i = 0; i \u003c m; i++) { int a, b, v; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026v); edges[a].push_back(node{b, v}); } dis[sta] = 0; //自己倒自己为0  int now = sta; //当前要被加入点集的节点编号  for (int i = 1; i \u003c n; i++) { ji[now] = 1; //表示已加入  int len = edges[now].size(); for (int j = 0; j \u003c len; j++) //尝试松弛相连节点  { if (dis[now] + edges[now][j].val \u003c dis[edges[now][j].next]) dis[edges[now][j].next] = dis[now] + edges[now][j].val; } now = lowest(); //找到下一个加入点集的节点  } for (int i = 1; i \u003c= n; i++) { printf(\"%d \", dis[i]); } return 0; } 优化后code：\n用堆(优先队列)来找到dis最小的结点的复杂度为 $O(\\log{n})$。\n当一个节点的dis从 $\\infty$ 被更新到一个值时会被加入优先队列，若没有更改，则所有可能到达的点的最小dis都被加入优先队列。\n#include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003cqueue\u003econst int maxe = 1e5 + 9, INF = 2147483647; struct node //邻接链表存图 { int next, val; bool friend operator\u003c(node a, node b) { return a.val \u003e b.val; } }; std::vector\u003cnode\u003e edges[maxe]; std::priority_queue\u003cnode\u003e run; int n, m, sta, dis[maxe]; bool ji[maxe]; //记录是否已经确定答案 int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026sta); for (int i = 1; i \u003c= n; i++) //初始化  { dis[i] = INF; } for (int i = 0; i \u003c m; i++) { int a, b, v; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026v); edges[a].push_back(node{b, v}); } dis[sta] = 0; //自己到自己为0  int now = sta; //当前要被加入点集的节点编号  for (int i = 1; i \u003c n; i++) { ji[now] = 1; //表示已加入  int len = edges[now].size(); for (int j = 0; j \u003c len; j++) //尝试松弛相连节点  { if (dis[now] + edges[now][j].val \u003c dis[edges[now][j].next]) { dis[edges[now][j].next] = dis[now] + edges[now][j].val; run.push(node{edges[now][j].next, dis[edges[now][j].next]}); //更新优先队列中的dis  } } while (!run.empty() \u0026\u0026 ji[run.top().next]) //清空已加入点集的点  run.pop(); if(run.empty()) //防止不能连通出现死循环  break; now = run.top().next; } for (int i = 1; i \u003c= n; i++) { printf(\"%d \", dis[i]); } return 0; } SPFA算法 Bellman-Ford算法的队列优化算法的别称。\n空间复杂度为 $O(n)$ 级别(不算图的存储)。\n在正常情况下(数据随机构造或出题人很善良)，期望的时间复杂度为 $O(km)\\space,\\space k\u003c2$，但是如果你碰上一个很厉(e)害(xin)的出题人，存在针对性数据，能把你卡成 $O(nm)$​，直接 T 飞！\n因此如果边权不为负的话，还是老老实实用Dijkstra叭。\nSPFA算法的实现有两种方式：\n DFS：在判定负环上优势明显，但求最短路即使各种优化，仍不及BFS。 BFS：整体速度高于DFS，但应在仅需判断负环的题中弃用。  因此，应按照题目要求，选择对应的算法和方式。\nBFS方式 最常见也是综合最优。\n 初始化：将dis数组除起点外赋值为 $\\infty$ ，起点dis为$0$​，将起点加入run队列。 松弛：将队头弹出，并使用与其相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新并且 $i$ 号节点不再run队列中，则将 $i$ 加入run的队尾。 重复执行松弛操作，直到队列为空。  优化原理：因为并不是dis一更新就继续迭代，而是很可能dis被更新多次之后才再次迭代，因此比DFS更优。\n#include \u003ccstdio\u003e#include \u003cqueue\u003e#include \u003cvector\u003econst int maxe = 1e5 + 9, INF = 2147483647; int n, m, sta, dis[maxe]; //1 struct node //邻接链表存图 { int next, val; }; std::vector\u003cnode\u003e edges[maxe]; std::queue\u003cint\u003e run; bool in[maxe]; int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026sta); for (int i = 1; i \u003c= n; i++) //初始化  { dis[i] = INF; } for (int i = 0; i \u003c m; i++) { int a, b, v; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026v); edges[a].push_back(node{b, v}); } run.push(sta); //将起点加入队列  dis[sta] = 0; while (!run.empty()) { int now = run.front(); run.pop(); in[now] = 0; //使队列中没有now  int len = edges[now].size(); for (int i = 0; i \u003c len; i++) { if (dis[edges[now][i].next] \u003e dis[now] + edges[now][i].val) //松弛操作  { dis[edges[now][i].next] = dis[now] + edges[now][i].val; //2  if (!in[edges[now][i].next]) //如果队列中没有  { run.push(edges[now][i].next); //加入队列并标记  in[edges[now][i].next] = 1; } } } } for (int i = 1; i \u003c= n; i++) { printf(\"%d \", dis[i]); } return 0; } 对于负环的判断 记录当前路径的最短路经过的边的数量，若边数大于总节点数，则说明一定有一条边被走了两次，证明有负环的存在。\n代码实现也很简单：\n//在上面标号1的地方加入 int pass[maxe]; //在上面标号2的地方加入 pass[edges[now][i].next] = pass[now] + 1; if (pass[edges[now][i].next] \u003e n) { printf(\"orz\"); return 0; } 还有一种比较玄学的判负环方式，就是如果扩展了MAXN次还没出结果，就判定有负环。（MAXN为根据题目规模自拟的常量）\n原理简单易懂：跑了这么久还没出结果，当然是有负环咯~~NB的是经实测正确率还相当高！当然相当高还是牺牲了算法的正确性的，因此不到万不得已之时不建议使用(玄学你懂的)。\n一些优化的方法 总体思想就是在你被出题人构造数据的情况下，如何能另辟蹊径，做出一些让出题人意想不到、另人捧腹大笑的sao操作，从而达到骗分的效果。\n 简单的优化(只能让你的spfa跑的快一点，适用于常数大的同学。至于卡了spfa的题，仍旧没有什么用处。)  SLF(Small Label First)优化： 在使用queue作为spfa的辅助数据结构时，将队列替换为双端队列，每当插入元素 $now$ 时，与队首进行比较，若 $dis[q.front()] \u003e dis[now]$，将 $now$ 从队首插入，否则从队尾插入，使得更可能更新出节点最优解的节点最先进行更新，减少无用迭代次数。 LLL(Large Label Last）优化： 使用双端队列，维护目前队列中元素到起点的距离的平均值（即 $\\sum^{tail}_{i=head}dis[edges[i]/n]$），设该数为 $k$，若 $dis[now] \u003e k$，则从队尾插入，否则从队首插入，用处不大。   升级的优化 (能过数据不刁钻的卡spfa的题，至于某些丧心病狂的出题人，拜拜了您嘞)  容错后的SLF： 定义容错值 $val$，当满足 $dis[now] \u003e dis[q.front()] + val$ 时从队尾插入，否则从队首插入，可以让程序不陷入局部最优解。 mcfx优化： 定义区间 $[l,r]$，当入队节点的入队次数属于这个区间的时候，从队首插入，否则从队尾插入，如过某个节点出发的大多数边都只能更新一个次解，那么它在队列中的优先级就会降低，防止链式结构卡死你。 Swap-SLF： 若队列改变且 $dis[q.front()] \u003e dis[q.back()]$​​，交换队首队尾，比较玄学。   玄学的优化(都是sao操作，能过多少看人品)  边序随机： 将读入给你的边随机打乱后进行spfa 队列随机： 每个节点入队时，以 $\\frac{1}{2}$ 的概率从队首入队，$\\frac{1}{2}$​ 的概率从队尾入队。 队列随机优化版： 累计 $m$ 次入队后，将队列元素随机打乱。    DFS方式 经过极其强大的优化后速度可能和BFS同级，但是在仅判断负环的问题中十分快。\n 初始化：将dis数组除起点外赋值为 $\\infty$ ，起点dis为$0$，将起点加入run队列。 递归松弛：使用与当期节点相连的边更新其他相连节点的dis值，若 $i$ 号节点的dis值被更新，则对 $i$​ 号节点递归操作。 重复递归，直到无法更新。  由于这种东西的实用性过低，不给出标程(实际上是懒得)。\n关于优化 姜碧野的《spfa算法的优化及应用》十分详细且难以理解。\n对于负环的判断 十分新奇，其实只需要记住结论即可。证明：文档\n结论即为：若存在负环，则一定存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点依次相加始终为负。\n所以，我们可以将dis数组初始值设为 $0$​，然后以每个节点为起点DFS，如果路径dis为正数就结束递归，这样相比于BFS方式可以忽略掉众多无用的边。\n但是，这种方法不能求最短路。\n最短路图 对于只能在最短路径上操作且可能同时存在多条最短路的问题时，可以采用建最短路图的方法。\n将在 $i$ 和 $j$ 的最短路径上的边放入一个新的图当中，使得问题可以在一个DAG（有向无环图）上操作，因为最短路保证不出现环。\n最短路图的建立(有一点点dp的感jio)：\n首先，分别以 $i$ 和 $j$​ 跑一遍单源最短路(会用到)。\n首先，思考一个事情，如何判断一条边是否在最短路图中？\n当且仅当其满足 $dis_i[start]+val+dis_j[end]=dis_i[j]$ 时。\n翻译一下，就是从 $i$ 到边起点的最短路径长度加上路径的权值再加 $j$ 到路径终点的最短路径长度等于 $i$ 到 $j$​ 的最短路径长度，因为只有这样，才能保证最短路径长度不变，即一种可能的情况。\n分层图最短路 用于求解一些有复杂决策的问题。\n在一个正常的图上可以进行 k 次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态了。\n就是将每个点根据状态的不同拆成若干个点，用拆出来的所有点建立新图并跑最短路。\n一般有两种方案：\n  建图时直接建成k+1层。\n  多开一维记录其余(决策)信息，但是对于多种决策用处不大。\n  然后，在新建立的图中跑最短路。\n","categories":"","description":"为了防止跑断腿儿，我们要学聪明一点。\n","excerpt":"为了防止跑断腿儿，我们要学聪明一点。\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","tags":"","title":"最短路径"},{"body":"倍增 ","categories":"","description":"倍增，很多算法中均有应用，它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。\n","excerpt":"倍增，很多算法中均有应用，它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。\n","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E5%80%8D%E5%A2%9E/","tags":"","title":"倍增"},{"body":"一种优美的简化暴力。\n","categories":"","description":"","excerpt":"一种优美的简化暴力。\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","tags":"","title":"动态规划"},{"body":"区间dp 顾名思义，就是在区间上进行dp。\n区间DP用于解决决策涉及到相邻区间合并的问题。\n它的转移方向是由小区间向大区间转移，所以在转移的时候，要注意转移顺序。\n经典例题一发 P1880 [NOI1995] 石子合并\n先来看状态转移方程： $$ dp[i][j]=max(dp[i][k]+dp[k+1][j])+\\sum^j_inum[i] $$ $dp[i][j]$ 表示以 $i$ 为起点，$j$ 为终点的区间合并成一堆所取到的最大。因为无论如何合并，本次合并所付出的代价相同，均为 $\\sum^j_inum[i]$。\n所以，我们只需要考虑如何搞才能让合并前的两堆的代价之和最大即可。\n方法就是遍历中间点 $k$，表示两堆的分割点，也就遍历了所有可能的合并情况，从中取最优，这也正是区间dp的精华所在。\n我们发现，跑完之后的dp数组中成三角形，这也正是区间dp区别于线性dp最显而易见的地方。\n环 很多时候，题目中会给出“……连成一个环”。\n这似乎，又是一个很难很难的问题……\n不，聪明的人类总是有流氓的做法。\n其实，就是把原来的数组在结尾在拼接一个一样的，但是最长的区间长度不变即可。(注意遍历时区间起止点的坐标范围和 $+1$ 问题)\n几道题 莫得办法，dp这玩意只能用题去体会。\n","categories":"","description":"在一个区域内不干好事。\n","excerpt":"在一个区域内不干好事。\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/","tags":"","title":"区间dp"},{"body":"","categories":"","description":"按照拥有钱的多少排名……哎！\n","excerpt":"按照拥有钱的多少排名……哎！\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/","tags":"","title":"堆"},{"body":"中国古典文学巨作《红楼梦》的白话文翻译。\n为了学好古文,我太难了……\n","categories":"","description":"","excerpt":"中国古典文学巨作《红楼梦》的白话文翻译。\n为了学好古文,我太难了……\n","ref":"/red-building/","tags":"","title":"红楼梦"},{"body":"SPFA-DFS负环证明 结论 让我们先来看结论：\n如上图，明显可以看出 4 -\u003e 5 -\u003e 6 -\u003e 7 -\u003e 8 -\u003e 9 -\u003e 10 -\u003e 11 -\u003e 12 -\u003e 4 构成了一个负环。\n以任意节点为起点，用SPFA-DFS查找负环，则有：\n​\t若存在负环，则一定存在特定的至少一对终止点之间的不重叠顶点最短路径的边权从起点依次相加始终为负。\n正解 我们只考虑在负环上的节点(因为我们只需证明这样的点对存在，非负权边节点情况过于复杂且并不影响答案的正确性，故忽略)。\n我们对这个图重复进行如下操作：\n 对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。  对于一个正负权边交替相连的图，将一条负边 $i$​，$i$​ 的起止两个节点和 $i$​ 指向的正权边分为一组，求两个边权和并作为新边边权合并。新的边表示已 $i$​ 的起点为遍历起点，经过两条边之后的边权和。和为负，则说明可以走过这两条边；和为正，则说明不可以以其作为起点。   第3步第4步直到图中仅剩下两个节点和两条边，这时，一定有两边之和小于0。(因为两边之和即为环上边权之和)\n因此，从这时负边的起点开始遍历原来的负环，保证边权依次相加为负。\n对于任意一条负边，表示从起始节点到终止节点所包含的边依次相加为负，边权为从起点走到终点后的边权和。我们每次选择的均为负边起点。\n伪证(早期的一些想法) 首先，我们对于连续的正(负)权边进行合并，并删去权值为0的边，得到一个正负权边交替相连的图。\n因为是负权边，所以有 $\\abs{\\sum^m_ival[i]|i\\in{(-\\infty,0)}}\u003e\\abs{\\sum_i^mval[i]|i\\in{(0,\\infty)}}$。若存在 $i$ 正权边大于与之相邻的 $j$ 负权边，那么一定存在另一负权边绝对值大于与之相邻的正权边加 $i+j$。\n对于任意负环(边权和为负的部分)，我们将它任意切割成两半，共有两种情况：\n  任意一半的边权之和都小于 $0$​  一半边权之和大于 $0$，另一半小于 $0$ (设两半边权之和为 $a$ 和 $b$，则有 $a+b\u003c0$ 。所以，当 $a\u003e0$ 时，一定有 $b\u003c0$​ )\n  对于任意边权和为正的部分，我们将它任意切割成两半，共有两种情况：\n 任意一半的边权和为正 其中一半的边权和为负，另一半为正  我们发现，当我们对边权和为负的部分进行 $n$​ 次切割直到有至少两个部分边权和为负，并且 $\\abs{\\sum边权和为负的部分}\u003e\\abs{\\sum边权和为正的部分}$ ​。\n操作：\n 对于任意一条最短路径，若其中有任何一个点在负环中，则其长度为 $-\\infty$，并且路径上存在多次访问节点，所以当一个顶点被第二次加入最短路并且其 $dis\u003c0$，证明有负环。 很显然，我们并不能跑通常意义下的最短路(肯定比SPFA-BFS慢很多，失去意义)，而是当任何时刻$dis\u003e0$​时终止递归。 如2，我们只寻找了以起点为负环上特定顶点的情况，所以需要对每个顶点执行同样的操作。 此算法理论上只需要跑一遍负环即可，而无需走 $n$ 条边。  然后就写不下去了…………\n","categories":"","description":"一篇小小的证明。\n","excerpt":"一篇小小的证明。\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/spfa-dfs%E8%B4%9F%E7%8E%AF%E8%AF%81%E6%98%8E/","tags":"","title":"SPFA-DFS负环证明"},{"body":"","categories":"","description":"一种无限接近答案（？）的思想。\n","excerpt":"一种无限接近答案（？）的思想。\n","ref":"/oiblogs/basic%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/%E4%B8%89%E5%88%86/","tags":"","title":"三分"},{"body":"","categories":"","description":"两个有钱人的队列并到一块……\n","excerpt":"两个有钱人的队列并到一块……\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E5%81%8F%E6%A0%91%E5%8F%AF%E5%B9%B6%E5%A0%86/","tags":"","title":"左偏树（可并堆）"},{"body":"适度数据结构益寿，过渡数据结构伤身。\n","categories":"","description":"","excerpt":"适度数据结构益寿，过渡数据结构伤身。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":"","title":"数据结构"},{"body":"树形dp 树上最大独立集问题 树形dp最经典的问题。\n问题详情 一句话：给一棵大小为 $n$ 的树，求最大点权独立集。\n先来看一下啥是独立集，再考虑最大点权的问题。\n选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。\n**最大点权：**即在所有可能存在的独立集中，点权之和(若没有点权，则认为所有点的点权都是$1$)最大的称为最大点权独立集。\n聪明的你立刻联想到了最大独立集=最大匹配！\n醒醒，二分图匹配没有点权。\n因此，我们要使用dp思想！\n首先，解决第一个问题——很可能题目并没有指定根节点($root$)，而仅仅给了你一个无向连通图($n$ 个节点 $n-1$ 条边，保证任意两两节点连通)\n我们直接任意选择一个作为根($root$)不就完了嘛！就是这么简单粗暴\n对于整个大问题，dp就是不断求解一个个小问题的过程。\n对于任意一个节点，状态只有两种：\n 在最大点权独立集中。 不在最大点权独立集中。  因此，我们用 $dp[i][0]$ 表示节点 $i$ 不在独立集中时以节点 $i$ 为根的树的最大点权独立集；用 $dp[i][1]$ 表示节点 $i$ 在独立集中时以节点 $i$ 为根的树的最大点权独立集。\n状态转移方程: $$ \\begin{aligned} \u0026dp[i][1]=\\sum dp[son[i][a]][0]\\space+val[i] \\\u0026dp[i][0]=\\sum max(dp[son[i][a]][0],dp[son[i][a]][1]) \\end{aligned} $$ $son[i][a]$ 记录节点 $i$ 的儿子。\n如果节点 $i$ 在独立集中，则 $i$ 的任何儿子一定不在独立集中。因此，我们只需要把以 $i$ 的儿子们为根且根节点不在独立集中的最大独立集求和再加上节点 $i$ 的点权，就得到正确的解。\n而如果节点 $i$ 不在独立集中，则 $i$ 的儿子在与不在均可。因此，我们要把以 $i$ 的儿子们为根的最大独立集(因此要在根节点在和不在两个中取最大值)求和即可。\n而dp完成后，可得到 $ans=max(dp[root][0],dp[root][1])$。\n至于如何遍历一棵树，当然是DFS！\ninstall APPs！ 众所周知(就算你不知，现在也知了)，背包是可以挂在树上的。\n433大大的疑惑：现在，433明白，自己需要 $n$ 个软件，并且假设她清楚每个软件所需要的安装时间 $w[i]$ 以及实用价值(搞完之后$jj$们能获得的满足感) $val[i]$ (虽然但是这并不可能)，而她因为要练习~~(不，因为烦躁)~~，只有 $m$ 的时间来搞这些事情(否则将因个人原因摧残与迫害电脑)。但是，众所周知(虽然但是可能433不知)，某一些软件依赖于其他软件(这里，我们规定若存在依赖，有且仅有一个依赖项)，如：美颜相机依赖于摄像头驱动——一种433不会搞的东西($jj$们为此卖力的教)，所以，安装任何软件之前，都应确保其依赖的软件全部安装。问能取得的最大价值是多少。\n由上述问题我们发现，软件之间具有依赖关系，一般地，某个物品的依赖物品只有一个~~(如果有多个的话可以考虑把出题人挂在树上)~~(但某个物品可以同时被多个物品依赖)，且依赖关系可以表示为一棵树：如果选择一个物品，则必须选择它的父节点。\n比如，若我们规定 $a$ 依赖于 $b$ 表示为 $a\\rightarrow{b}$，则 $$ b\\rightarrow{a} \\c\\rightarrow{a} \\d\\rightarrow{a} \\e\\rightarrow{b} \\f\\rightarrow{b} \\g\\rightarrow{c} $$\n可以用下图表示：\n思路 背包和树形dp结合，转化为分组背包问题。\n首先，我们明确，进行树形dp时我们是从下至上进行的，因此我们对节点 $i$ 进行状态转移时，节点 $i$ 的所有儿子的dp值是已知的。\n$dp[i][j]$ 表示以节点 $i$ 为根的树中背包容量为 $j$ 时所能取得的最大价值。\n由图的意义我们可以得知，如果要选择以节点 $i$ 为根节点的树中任意一个节点，都必须选择节点 $i$ (必须按照深度逐一装)。\n因此，留给节点 $i$ 的儿子们的空间只有 $j-w[i]$。我们要在节点 $i$ 的 $k$ 个儿子中，每个儿子分配 $t_k$ 的背包空间，使得 $\\sum_{a=1}^kdp[son[i][a]][t_a]\\space|\\sum_{a=1}^kt_a=j-w[i]$ 最大。\n对此，我们直接进行三重循环即可。因此，时间复杂度为 $O(n^3)$。\n环 我们知道一般图上是无法dp的。因为图上的环会导致循环转移，即存在后效性(求出的dp值可能不正确)。这在dp问题中是不允许存在的。\n一般图转化为无环图的主要方法是将强连通分量缩成一个点。\n依赖性背包中的强连通分量就是一个环。环中的每个点或者全选，或者全不选，因此可以缩点。\n将强连通分量中的每个点的重量求和作为新点的重量，价值求和作为新点的价值。\n剩下的就是依赖性背包板子了。\n最后的一点儿 我们将所有依赖关系连边之后就形成一张图。\n如果没有“循环依赖”关系（即环），这些依赖关系就形成若干棵外向树，即外向树森林。\n建立虚拟根节点，价值和重量均为 $0$，并将所有没有依赖的物品都与 $root$ 连边，则转化为一棵外向树。\n基环树上的dp 首先 在学习基环树上的dp之前，就得先把标题看懂——了解奇环树是啥。\n奇环树，就是：\n 在一棵树上增加一条边。 个树上有一个环。 有 $n$ 个点和 $m$ 条边的无向连通图。  奇环树的情况：\n 无向 有向  基环外向树(每个点只有一条入边)。 基环内向树(每个点只有一条出边)。    因为奇环树的边数 $-1$ 便形成了一棵树，因此仍将其视作”树”来解决问题。\n（没看懂）每个点只和一个点连边所形成的无向图一定是一片基环树森林。\n对于这种恶心的树，我们也采取一种暴力的手段来对付，就是在环上任意删一条边，然后转化为一棵树，跑树形dp即可。\n找环 不管你对于出题人命制的题目有多大的意见~~(tmd，为神魔有环——优美中国话)~~，你都得一步步来——先找到环。\n找到一条边即可，不需要记录所有环上节点。\n  无向图：\n 你飞速的撸出了一窜拓扑排序的模板。 接着，恭喜，环找到了。(入度 $\\ge{2}$ 的点就是环上的点，和上一个被访问的点之间的边一定是环边)    有向图：\n 你疯狂的搞出了一份DFS标准模板，调试完成。 恭喜，环也找到了。(DFS时若某一个节点被访问第二次，即是环上的点，和上一个被访问的点之间的边一定是环边)    round $1$ 但是注意，当我们删去边 $u\\rightarrow{v}$ 并以节点 $u$ 为根跑树形dp后，虽然进行了删边操作，但实际上是有的，因此节点 $u$ 和节点 $v$ 仅能选择其中一个，从而出现两种情况：\n $dp[u][0]$ 表示强制不选节点 $u$，因此对于节点 $v$ 是否选择无限制，此情况一定成立。 $dp[u][1]$ 表示强制选择节点 $u$，这时候节点 $v$ 必定不可以选择，但是我们并不清楚节点 $v$ 的选择情况，所以这个dp值在某些情况下是错误的，不能取。  $dp[u][0]$ 对于节点 $u$ 和 $v$ 的选和不选两种状态的覆盖情况为：\n   节点 选 不选     $u$ $\\times$ $\\checkmark$   $v$ $\\checkmark$ $\\checkmark$    因此，我们需要考虑一下一定选择 $u$ 节点的情况，因此，我们以节点 $v$ 为根再跑一遍树状dp，而 $dp[v][0]$ 就包含了选择节点 $u$ 的情况。\n最后，我们需要在两种情况下选择较大值 $max(dp[u][0],dp[v][0])$ 即可。\nround $2$ 对于这个选与不选的问题，还有一种思考的维度。\n我们考虑节点 $u$ 可能的两种情况：\n $dp[u][0]$ 强制不选，这时对节点 $v$ 的状态没有要求，不做处理，正常跑dp即可。、 $dp[i][1]$ 强制选择，这时节点 $v$ 必须不选，因此，再跑一次dp，将 $dp[v][1]$ 初始化为 $-\\infty$ (表示不存在这种情况，进行dp时是不会选择如此不好的节点的，强制保证了不选节点 $v$)。  外向DAG 每个点都有且只有一个入度，并且环内的节点方向指向环外，因此任何一个点沿着唯一入边走都会走到环上。\n内向DAG 每个点都有且只有一个出度，并且环外的节点方向指向环内，因此任何一个点沿着唯一出边走都会走到环上。\n有向无环图(DAG)上的dp(拓扑序dp) 因为有向无环图有拓扑序，所以我们按拓扑序转移即可保证无后效性(即改变已经访问过的节点)。\nDAG上的dp可以在 $O(n+m)$ 的时间复杂度内解决DAG上最短/最长路、最短路计数等基本问题。\n其他应用(一些奇怪的题的题解) 有时间再补\n","categories":"","description":"你在爬树……\n","excerpt":"你在爬树……\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/","tags":"","title":"树形dp"},{"body":"强连通分量与缩点 又是啥玩意 强连通 在**有向图 **$G$ 中，两个顶点 $u$，$v$ 间有一条从 $u$ 到 $v$ 的有向路径，同时还有一条从 $v$ 到 $u$ 的有向路径，则节点 $u$ 和 节点 $v$ 强连通。\n啥玩意嘛。\n简单一点，有向图中，两个节点之间可以互相到达，则这两个节点强连通。\n强连通图 若有向图 $G$ 的每两个顶点都强连通，则 $G$ 是一个强连通图。\n强连通分量 有向非强连通图的极大强连通子图，称为强连通分量。\n又是嘛?\n一个图 $G$，如果是有向图，但是不是强连通图，则图 $G$ 的所有是强连通图的子图中最大的(节点数最多的)称为强连通分量。\n咋求？(向你缓缓打出一个？) Tarjan算法 经典算法？\n首先，需要知道关于DFS生成树的一些东西。\n观察发现，任何一个强连通分量中必须有至少一个返祖边，因此如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。$u$ 被称为这个强连通分量的根。Tarjan便以此为基础，进行求解。\n维护变量  $dfn[i]$：维护节点 $i$ 的dfs搜索序。 $low[i]$：维护节点 $i$ 的子树中和子树中通过一条不在搜索树上的边能到达的所有结点的最小dfn值。 $stack:run$：维护一个队列，保证上面的节点在以底下第一个 $low[i]=dfn[i]$ 的节点为根的强连通分量中。  从而我们得到两个推论：\n 上节点的 $dfn$ 都大于该结点的 $dfn$ 。 从根开始的一条路径上的 $dfn$ 严格递增，$low$ 严格非降。  三种情况 对于当前节点 $u$，有一条 $u\\rightarrow{v}$ 的边：\n 节点 $v$ 未被访问过：继续对 $v$ 进行深度搜索。在回溯过程中，更新 $low[u]=min(low[u],low[v])$。 节点 $v$ 被访问过，并且在栈中：说明找到一个返祖边，直接更新 $low[u]=min(low[u],low[v])$ 即可。 节点 $v$ 被访问过，并且不在栈中：节点 $v$ 的强连通分量的根节点已经被找到，其强连通分量已经确定，不用操作。  注意 当我们回溯到节点 $i$，发现其 $low[i]=dfn[i]$ 时，说明我们找到一个强连通分量的根节点，栈中在节点 $i$ 上面的都在以节点 $i$ 为根的强连通分量中，因此，对于 $\\forall{}\\space node\\space x\\in{upper\\space i},\\space low[x]=dfn[i]$ 。\n否则，看上图…………经过细致的观察，我们发现，节点 $1、7、5、8、3、4$ 为强连通分量。如果你不在出栈的时候再更新一次，你就惊喜的发现，$low[4]=4$ ？？？因为搜索到 $4\\rightarrow8$ 这条边的时候，因为节点 $8$ 刚刚搜搜索到一条至 $low=4$ 的节点，所以$low[8]=4$，就导致 $low[4]=4$，而后没有边再访问到节点 $4$，因此其 $low$ 值无法得到更新，始终为 $4$ ！！！然而，这显然是错的…………\n然后，注意一定要在子树都搜索完成后，在进行弹栈操作。这样，保证横叉边也可以积攒在栈中。\n缩点 看起来好高深的ya子\n这玩意菜的一批。\n就是对于原来图中的边 $u\\rightarrow v$ ，若 $low[u]\\neq low[v]$ ，则在新图中连接一条 $low[u]\\rightarrow low[v]$ 的边；若 $low[u]=low[v]$ ，则不执行任何操作。\n这时候，我们会发现有可能连重了…………不影响的，好吧，不要强迫症。\n板子 洛谷P3387 【模板】缩点\n#include \u003ccstdio\u003e#include \u003cstack\u003e#include \u003cvector\u003e#include \u003cbitset\u003e#include \u003calgorithm\u003eusing std::max; using std::min; const int maxn = 1e4 + 9; std::vector\u003cint\u003e next[maxn]; std::vector\u003cint\u003e nnet[maxn]; std::vector\u003cint\u003e root; std::stack\u003cint\u003e run; int n, m, val[maxn], dfn[maxn], low[maxn], cnt, nval[maxn], ans; std::bitset\u003cmaxn\u003e ins; void tarjan(int now) //我们直接使用dfn[i]==0?来判断节点 i 是否被访问过 { ins[now] = 1; //对于任何一个没有被访问过的节点,有可能是根,加入栈 \trun.push(now); dfn[now] = low[now] = ++cnt; //我们不清楚其子树 \tfor (int i : next[now])\t//遍历所有出度 \t{ if (!dfn[i]) //如果没有访问过,递归查找并update \t{ tarjan(i); low[now] = min(low[now], low[i]); } else if (ins[i]) //如果访问过,直接更新 \t{ low[now] = min(low[now], low[i]); } } if (dfn[now] == low[now]) //我们搜索完了整个子树,若成立,即可判断当前节点是强连通分量的根 \t{ while (!run.empty() \u0026\u0026 dfn[run.top()] != low[run.top()]) //将压在当前节点上的都弹出 \t{ nval[low[now]] += val[run.top()];\t//统计强连通分量中节点权值和 \tlow[run.top()] = min(low[run.top()], low[now]); //标记所有强连通分量的节！！！ \tins[run.top()] = 0;\t//不在栈中了 \trun.pop(); } run.pop(); //同上 \tins[now] = 0; nval[low[now]] += val[now]; } } void find(int now) //直接DFS暴搜找到最大路径 { cnt += nval[now]; int len = nnet[now].size(); if (!len) { ans = max(ans, cnt); } for (int i = 0; i \u003c len; i++) { find(nnet[now][i]); } cnt -= nval[now]; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026val[i]); } int u, v; for (int i = 0; i \u003c m; i++) { scanf(\"%d%d\", \u0026u, \u0026v); next[u].push_back(v); } for (int i = 1; i \u003c= n; i++) //防止出现非连通图,对于所有没被遍历到的点做Tarjan \t{ if (!dfn[i]) { ins.reset(); //多次不清空,暴零两行泪 \twhile (!run.empty()) run.pop(); tarjan(i); } } ins.reset(); //废物利用qwq \tfor (int j = 1; j \u003c= n; j++) { for (int i : next[j]) { if (low[j] != low[i]) //这就是传说中的缩点 \t{ nnet[low[j]].push_back(low[i]); ins[low[i]] = 1; //记录入度 \t} } } for (int i = 1; i \u003c= n; i++) { if (!ins[i]) //找到图中所有入度为0的点为根(非连通图可能有多个根) \t{ root.push_back(i); } } for (int now : root) //对于每个根,跑DFS \t{ cnt = 0; //又是废物利用qwq \tfind(now); } printf(\"%d\", ans); return 0; } ","categories":"","description":"断环成树？\n","excerpt":"断环成树？\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E7%BC%A9%E7%82%B9/","tags":"","title":"强连通分量与缩点"},{"body":"最不喜欢的东西…………qwq\n","categories":"","description":"","excerpt":"最不喜欢的东西…………qwq\n","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/","tags":"","title":"数论"},{"body":"平衡树 二叉搜索树 二叉搜索树是一种二叉树形的数据结构，各节点权值按中序遍历排列单调不增(或不降)。\n中序遍历：先左再中后右\n二叉搜索树上的基本操作所花费的时间与树的高度成正比。对于一个有 $n$​个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\\log{n})$​，最坏为 $O(n)$​。随机构造一棵二叉搜索树的期望高度为 $O(\\log{n})$​​。\n二叉搜索树其实是一个暴力版本的平衡树，平衡树在二叉搜索树上通过一些算法，将树高严格或期望维持在$\\log{n}$​​，但相差不会太大，保证不会退化成一条链。\n各家的平衡树 平衡树按照应用可以分为两类：\n 权值平衡树：维护一个有序可重集合(按权值排序，中序遍历为已排序的集合)； 序列平衡树：维护一个序列(按原始下标排序，中序遍历即为序列)，并不是所有平衡树都能够用作序列平衡树。  注意，并不是所有家的平衡树都能作为以上任意一种平衡树使用。\n按照平衡树高度又可以分为两类：\n 强平衡树：树高严格为$O(\\log{n})$ 弱平衡树：树高期望为$O(\\log{n})$  常见的平衡树有：\n Splay—伸展树 Treap—树堆  旋转式Treap 分裂式Treap(又称fhq-treap，因为是fhq发明的)   AVL树 SgT—替罪羊树(比较有意思，发现树高不为$\\log{n}$​时，整个推倒重新建树，复杂度竟然也不高!?) RBT—红黑树(最快的，没有之一，C++ STL都是这个，yyds!) …………  OI中较常用的是 Splay 和 fhq-treap(剩下的性价比不高，要就不是难写，要就不是即难写还慢)。\n所以，你的推是哪个?\nfhq-treap平衡树 这东西以一种不可思议的方式运行着。具体来说，就是一言不合，就把你劈成两半……怕了怕了\ntreap 这个单词是由 tree 和 heap 组合而来，这表明 Treap 是一种由树和堆组合形成的数据结构。\n高级之处   代码短，比线段树长不了多少。\n  思想简单易懂，导致的就是Debug时间减少。\n  两种平衡树均可使用。\n  可支持持久化。\n  准备工作 先来康康需要哪些变量：  son数组：记录每个节点的儿子节点的编号 son [i] [0] 表示 $i$​ 号节点左儿子的编号，son [i] [1] 为右儿子的编号。 tot：记录总结点个数，声明一个新节点时会用到。 root：记录根节点编号。 size数组：size[i]标记以 $i$ 节点为根的子树大小(包括 $i$ 号节点本身)。 val数组：记录每个节点的权值。 rnd数组：记录每个节点的随机优先级。fhq-treap 的每个结点上具有一个$priority$值 ，fhq-treap 除了要满足中序遍历有序的性质之外，还需满足父节点的 $priority$(随便一种关系，如大于、小于等于……)两个儿子的$priority$。在一般的实现中， $priority$是每个结点建立时随机生成的，因此 fhq-treap 是期望平衡的。  最基本的平衡树的空间复杂度为 $O(5n)$​，当然也可以动态优化，但并不能起到较为显著的效果(每个节点都有可能被访问)。\n宏定义 有效降低代码长度、出错概率以及Debug时间。\n#define Ls son[pos][0] #define Rs son[pos][1] build_new_node函数 声明一个新的节点\ninline int nnd(int x) //声明一个新的节点并分配priority值 { size[++tot] = 1; val[tot] = x; //注意，维护有序队列时，应把x替换成tot，想清楚要维护的是什么  rnd[tot] = rand(); return tot; } update函数 更新当前节点的size信息\ninline void upd(int pos) //更新节点size大小 { size[pos] = size[Rs] + size[Ls] + 1; } 核心操作——分裂与合并 分裂 一共两种分裂方法，适用于不同场景。（作为区间平衡树时只有按节点数分裂一种）.\n分裂基本原理为每次判断当前根节点将被分到左右哪侧，再递归分裂根节点位于另一侧的子树，将分裂结果的同侧部分接在原位。\n  按权值分裂：\n  按照设定的key值为分裂条件，将小于等于key的节点挂在左边，大于key的挂在右边。\n  inline void spv(int pos, int key, int \u0026l, int \u0026r) //按照权值分裂,pos当前节点编号,key分裂值,\u0026l左侧挂载位置,\u0026r右侧挂载位置 { if (pos == 0) //没有叶子节点,结束递归  { l = r = 0; //没有叶子节点,结束递归,并将挂载点赋值0(空)  return; } if (val[pos] \u003c= key) //如果当前节点小于等于key,则将左子树(都小于当前节点,所以都小于key值)和当前节点挂在左侧,继续分裂右子树  { l = pos; //挂在上次传递的挂载点位置  spv(Rs, key, Rs, r); //递归分裂右子树,因为右子树中所有值均大于当前节点,因此如果仍有小于key值的应挂在当前节点的右儿子的地方  } else //如果当前节点大于key,则将右子树(都大于当前节点,所以都大于key值)和当前节点挂在右侧,继续分裂左子树  { r = pos; //挂在上次传递的挂载点位置  spv(Ls, key, l, Ls); //递归分裂左子树,因为左子树中所有值均小于当前节点,因此如果仍有大于key值的应挂在当前节点的左儿子的地方  } upd(pos); //更新节点size大小(因为分裂开后,子树大小有改变) }     按节点个数分裂：\n  按照设定的key值，在左侧挂key个最小的节点，其余的挂在右侧。\n  inline void spn(int pos, int key, int \u0026l, int \u0026r) //按照节点个数分裂,pos当前节点编号,key分裂值,\u0026l左侧挂载位置,\u0026r右侧挂载位置 { if (pos == 0) //没有叶子节点,结束递归,并将挂载点赋值0(空)  { l = r = 0; return; } if (size[Ls] + 1 \u003c= key) //如果左子树和当前节点个数之和小于等于key,则挂在左侧,继续在右子树中选key-size[Ls]-1个加入左侧  { l = pos; //挂在上次传递的挂载点位置  spn(Rs, key - size[Ls] - 1, Rs, r); //递归分裂右子树,因为已经在左侧又挂了size[Ls]+1个节点,所以要在右子树中再选key-size[Ls]-1个即可  } else //如果左子树和当前节点个数之和大于key,不满足条件,继续在右子树查找size合适的子树  { r = pos; //挂在上次传递的挂载点位置  spn(Ls, key, l, Ls); //递归分裂左子树,因为并没有在左侧挂任何节点,因此key不改变  } upd(pos); //更新节点size大小(因为分裂开后,子树大小有改变) }     合并 合并是分裂的逆操作，基本原理为按照优先级判断哪棵树的根将成为新树的根，之后递归地合并另一棵树与当前树的对应子树。\n需要注意的是：fhq-treap 的合并操作相当于只是简单拼接两棵树的中序遍历，不会检查权值是否有序(理论上如果操作正确的话，分裂出的子树均为有序)，如果被合并的两棵树权值大小关系有误，将导致之后按权值分裂是出现不可预期的结果！\ninline int tog(int l, int r) //合并两棵树,l左侧树的根节点,r右侧树的根节点;递归思想 { if (l == 0 || r == 0) //如果任意一个树是空的,剩余的树的根节点就是挂载点  return l + r; if (rnd[l] \u003c rnd[r]) //优先级定义,可以随便写  { son[l][1] = tog(son[l][1], r); //右侧树挂载左侧树的右侧  upd(l); //更新左侧树根节点的信息  return l; //返回新树的根节点  } son[r][0] = tog(l, son[r][0]); //左侧树挂载右侧树的左侧  upd(r); //更新右侧树根节点的信息  return r; //返回新树的根节点 } 各种操作 总之就是使用上面三种核心操作，实现的一系列qwq的实际操作。\n感受fhq脑洞之大吧\ninside插入 inline void ins(int v) { spv(root, v, ll, rr); //按照v分割成根节点为ll和rr两棵子树  root = tog(tog(ll, nnd(v)), rr); //先合并ll和新加入的节点,再和rr合并,然后更新总树的根节点 } delete删除 若有多个相同的数，只删除一个。\ninline void del(int val) { spv(root, val, ll, rr); //按照v分割成根节点为ll和rr两棵子树  spn(ll, size[ll] - 1, ll, LL); //再在左侧分割出1个节点挂在右侧  root = tog(ll, rr); //合并新ll和rr,不合并第二次分裂的右侧1个节点,即删除,然后更新总树的根节点 } order-value查询key值的排名 排名定义为比当前数小的数的个数 $+1$ 。\ninline int ordv(int v) { spv(root, v - 1, ll, rr); //将所有小于v的数分割  int r = size[ll]; //记录根节点size,即所有小于v的节点的数量,后续合并时可能变化  root = tog(ll, rr); //合并分裂开的两棵树  return r + 1; //返回注意+1 } order-num查询第key个数的值 inline int ordn(int k) { spn(root, k, ll, rr); //分裂出前k个节点  spn(ll, k - 1, ll, RR); //再分裂出前k-1个节点,这样右侧就有一个排名为k的节点,其下标为RR  root = tog(tog(ll, RR), rr); //合并分裂开的两棵树  return val[RR]; //返回编号为RR的节点的权值 } fir查询前驱(前驱定义为小于x，且最大的数) inline int fit(int v) { spv(root, v - 1, ll, rr); //先分裂出所有小于v的节点  spn(ll, size[ll] - 1, ll, RR); //再在小于v的节点中分裂出最大的一个,因为ll是根节点,size[ll]即为小于v的节点数量  root = tog(tog(ll, RR), rr); //合并分裂开的ll,前缀和rr  return val[RR]; //返回前驱的值 } back查询后继(后继定义为大于x，且最小的数) inline int back(int v) { spv(root, v, ll, rr); //先分裂出所有小于等于v的节点  spn(rr, 1, LL, rr); //再在大于v的节点中分裂出最小的一个  root = tog(tog(ll, LL), rr); //合并分裂开的ll,后缀和rr  return val[LL]; //返回后缀的值 } “懒”标记 在某些时候，当实现一个对于区间的操作时，也可以在平衡树上使用“懒”标记以达到降低时间复杂度的目的。\n和线段树一样，也应该注意标记的下放和优先级关系。\n","categories":"","description":"一棵树，长得十分的对称。\n","excerpt":"一棵树，长得十分的对称。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E8%A1%A1%E6%A0%91/","tags":"","title":"平衡树"},{"body":"状压dp 又是二进制的东西……烦躁\n这东西只是一个辅助，用来优化暴力或dp空间的。\n用武之地 当状态维数 $n$ 很多但每一维状态数 $k$ 都很少(一般是 $2$)的时候，我们可以用一个 $n$ 位 $k$ 进制整数来表示这维状态。\n下面，我们单表状态数为 $2$ 的情况。\n在学习状压dp之前，我们应该清楚所有的dp是解决多阶段决策最优化问题的一种思想方法。请注意多阶段这三个字，如何定义状态是动态规划最重要的一步。状态的定义也就决定了阶段的划分。\n动态规划多阶段一个重要的特性就是无后效性(值对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的发展，而只能通过当前的这个状态。换句话说影响当前阶段状态只可能是前一阶段的状态，而不能是后续的状态)\n那么可以看出如何定义状态是至关重要的，因为状态决定了阶段的划分，阶段的划分保证了无后效性。\n因此，我们为了保证无后效性，通常要在转移的时候带上足够的数据(很可能是一个数组)，这时的空间开销就会很大，因此我们把原数组中的每一位表示为某一个数字的某一位，这样只需要携带 $O(1)$ 的空间转移了。\n例子 我们回想01背包，如果我们要让你记录一下具体是怎么装的如何？当时，我们给出了反向迭代推导的方法。\n但是，我们也可以在每次dp决策的时候就记录一下，并带着选择的方式转移，这样我们就不用回溯了(典型的牺牲空间换取时间的办法)。\n我们开了一个数组，bool ji[n][k][n](虽然可以一维优化)，但是我十分不爽，这搞的空间过大了！\n所以，我们想起了状压dp，因此，我们现在要降成二维int ji[n][k]，$ji[i][j]$ 表示对应dp表第 $i$ 行第 $j$ 列的选择方式：第 $1$ 个物品对应 $ji[i][j]$ 第一位的 $0/1$，第 $2$ 个对应第二位的 $0/1\\space\\dots\\dots$\n然后，我们把这个二进制数存在一个int里不就可了嘛，这样你就塞下了 $32$ 位的状态，真香。\n从 $O(n!)$ 到 $O(2^n)$ 状压dp是最接近暴力的一种dp，因为它可以完整地记录每一种状态。\n但它又比 $O(n!)$ 的纯暴力搜索要优一些，因为它舍弃了状态的更新顺序的记录。\n所以很多情况下，状压dp就是将 $O(n!)$ 的暴力优化到的另一个 $O(2^n)$ 暴力的过程。\n子集枚举 合理运用小范围数据 状压dp中 $2^n$ 的复杂度使得题目中的某些数据范围也会很小（一般在 $25$ 以下）。当遇到 $\\le{25}$ 数据范围时一定要敏感。\n","categories":"","description":"压缩！压缩！（为啥不用bitset咧？）\n","excerpt":"压缩！压缩！（为啥不用bitset咧？）\n","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9dp/","tags":"","title":"状压dp"},{"body":"树链刨分 一种极致优化的树上算法，据说07年被某个集训队队员搞出来的。\n关于DFN序，参见搜索.md。\n一波约定 为方便起见,我们约定一棵树的某些数据如下：\n  $siz[i]$ 表示 $i$ 结点的子树大小\n  $dep[i]$ 表示 $i$ 结点的所在深度(定义根的所在深度为$1$)\n  $fa[i]$ 表示 $i$ 结点的父结点编号\n  $bson[i]$ 表示 $i$ 节点的重儿子的编号\n  $top[i]$ 表示 $i$ 节点所在链的顶端节点\n  儿子还分轻重? 对于任意一个非叶子结点，它的子结点中 $siz$ 最大的定义为它的重儿子，其余的子结点定义为它的轻儿子。注意：重儿子有且仅有一个，若有多个最大子树，任意选择一个为重儿子，其余为轻儿子即可。叶子节点没有重儿子。\n 很好理解，从字面上来看，重儿子就是子树中节点数最多的那一个，比较“重”；而剩下的儿子的子树节点数比较少，所以就“轻”。\n 这样，我们可以将树上的边也分为两类：父结点与重儿子之间连接的边为重边，与轻儿子连接的边为轻边。\n进而推广到，由多条重边连接而成的路径为重链。\n看一个例子：\n其中，黄色节点为其父亲节点的重儿子，白色为轻儿子；红色边为重边，黑色为轻边；绿色底为重链。\n如此划分，则：\n 轻边 $(u,v)$ 中, $size(u)≤ size(\\frac{v}{2})$   至少存在一个重儿子大于等于自己的 $size$。\n  从根到某一点的路径上,不超过 $\\log{n}$ 条轻链和不超过 $\\log{n}$ 条重链。\n  树中任意两个节点之间的路径，都可以将其拆分为不超过 $4\\log{n}$ 条重链 + 轻边\n  它来了 本质上是一种优化暴力\n首先，完成树链剖分，有如下操作：\n  求出每个节点的子树大小(找到重儿子)，每个节点的深度\n  在第 $1$ 步的基础上，找出每条轻链和重链\n  简化一下，就是先DFS一次，求DFS序，把烂七八糟的填上；然后再来一次，把轻链和重链搞出来，完事。\n第一次：\ninline void dfs1(int now, int deep) { dep[now] = deep; int big = 0; //别忘了初始化  for (auto i : next[now]) { if (!fa[i]) //无向图判断是否是父节点，防止死循环  { fa[i] = now; //子节点的父亲是自己  dfs1(i, deep + 1); //递归遍历  if (size[i] \u003e big) //有更重的儿子  { big = size[i]; son[now] = i; //标记重儿子  } size[now] += size[i]; //加上这个儿子的size  } } size[now]++; //加上自己的1个  return; } 第二次：\ninline void dfs2(int now, int t, bool big) { //这里如果要维护区间的话，要记录dfn序，注意先遍历重儿子  top[now] = t; //维护链顶端顶点  if (!son[now]) //叶子节点  return; dfs2(son[now], t, 1); //先递归查找重链  for (int i : next[now]) { if (i != fa[now] \u0026\u0026 i != son[now]) { dfs2(i, i, 0); //递归轻边  } } } 一些细节  轻链：  很多博文中，我们又看到了一个新的东西——轻链。\n其实，你是不能把轻边连成一条链的，看下图：\n我们观察发现，如果我们将 $9$ 挂到 $3$ 上面的话，就和 $3\\rightarrow8\\rightarrow10$ 这条重链重了，造成求解的失败。\ntop：  在树链刨分中，我们要把一条重链上的点看做一个点，即这条重链的顶点，比较是均以顶点去比较。\n跳转fa：  注意，每次跳转的时候，都要跳转到顶点的fa，否则就死循环卡那了。\n实战：求解LCA LCA，最近公共祖先。\n结点 $u$ 和 $v$ 向上跳，每次将深度较大的结点跳到自己所在的链的顶端结点，重复执行直至两个结点位于同一条重链上。\n一个一个的跳，防止跳过了。\n选择深度较大的点，保证了在跳到的链上从顶点到原先的深度可以反复横跳，这样，如果另一个深度较小的点也跳到了同一个链上，则上链深度一定在深度较大的点的横跳范围之内，所以就是LCA。\n这里注意，每次将链顶深度大的点向上跳，当在同一条链上时，取深度较小的点为LCA。\n时间复杂度为 $O(\\log{n})$\n[洛谷 P3379 【模板】最近公共祖先（LCA）][https://www.luogu.com.cn/problem/P3379]\n#include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003calgorithm\u003econst int maxn = 5e5 + 9; int n, m, root, size[maxn], son[maxn], top[maxn], dep[maxn], fa[maxn]; std::vector\u003cint\u003e next[maxn]; inline void dfs1(int now, int deep) { dep[now] = deep; int big = 0, ji = 0; for (auto i : next[now]) { if (!fa[i]) { fa[i] = now; dfs1(i, deep + 1); if (size[i] \u003e big) { big = size[i]; son[now] = i; } size[now] += size[i]; } } size[now]++; return; } inline void dfs2(int now, int t, bool big) { top[now] = t; if (!son[now]) return; dfs2(son[now], t, 1); for (int i : next[now]) { if (i != fa[now] \u0026\u0026 i != son[now]) { dfs2(i, i, 0); } } } inline int lca(int a, int b) { while (top[a] != top[b]) { if (dep[top[a]] \u003c dep[top[b]]) std::swap(a, b); a = fa[top[a]]; } return dep[a] \u003e dep[b] ? b : a; } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026root); for (int i = 1; i \u003c n; i++) { int a, b; scanf(\"%d%d\", \u0026a, \u0026b); next[a].push_back(b); next[b].push_back(a); } fa[root] = root; dfs1(root, 1); dfs2(root, root, 0); while (m--) { int a, b; scanf(\"%d%d\", \u0026a, \u0026b); printf(\"%d\\n\", lca(a, b)); } return 0; } ","categories":"","description":"把一棵树劈开的多重方法……\n","excerpt":"把一棵树劈开的多重方法……\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","tags":"","title":"树链刨分"},{"body":"","categories":"","description":"","excerpt":"","ref":"/oiblogs/dp%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/manacher%E7%AE%97%E6%B3%95/","tags":"","title":""},{"body":"树状数组 一种~~倍增?分治？~~思想下的奇奇怪怪的东西…………\n先放个图用的地方   正常数组的单点修改时间复杂度为$O(1)$，区间查询为$O(n)$; 而树状数组的单点修改和区间查询均为$O(\\log{n})$。（因为树的高度为$\\log{n}$）\n  相比于某个更sb的东西：\n  优点：\n  单次操作时间复杂度为$O(\\log{n})$​​且常数很小，实际运行效率远优于线段树(虽然理论上时间复杂度相同)\n  空间复杂度$O(n)$，在某些场景下较线段树($O(4n)$)有极大优势\n  理解以后很好写(它很短，不费手，不需Debug $_{除非手残}$​ (不理解也很好背) (理解是不可能理解的)\n  缺点：\n适用范围比线段树小的多。树状数组能有的操作，线段树一定有；线段树有的操作，树状数组大部分没有。\n最最最奇怪的地方 你这玩意谁想的粗来？\n先搞一个题外话——C++中对于负整数是如何存储的。 默认都知道变量会预留一个二进制位为符号位，虽然但是并没有什么关系且不知道也不影响\n对于一个负整数，存贮方法为先将这个数的绝对值取反，**再$+1$**​。(是不是十分反人类!?)\n举个栗子(上图也有)：$1$​​ –\u003e $(0001)_2$​ $-1$​ –\u003e $(1110)_2+(0001)_2$​​ –\u003e $(1111)_2$\n然后，我们惊喜的发现： 咦，如果我们吧原数和原数的相反数与起来好像不错……\n$1\u0026-1$ = $(0001)_2$ 好像又回来了？\n其实是我们得到了原数的lowbit，即原数二进制表示中为$1$的最低位。\n再观察，它好像正好转换成十进制就是它的长度…………\n这个世界好神奇!!!\n不理解就放过自己吧，背住就好\n终于，进入正题 最最最奇诡的东西过去了，剩下的就简单?了\n树状数组的第$i$位维护以第$i$位为终点，长度为$i\u0026-i$的区间和。\n更新时注意要将压在上面的全部更新\n查找时只能查找从$1\\sim i$的区间和；要想查找区间$[i,j]$的和，请用 $1\\sim j$ 的区间和减去 $1\\sim(i-1)$ 的区间和。\n注意! 是 $i-1$​​ 而不是 $i$​​ ​！！！ 从第$i$位开始向上查找，将所跳转到的求和，直到下标为$0$​。\n#include \u003ccstdio\u003econst int maxe = 5e5 + 9; int tree[maxe], n, m; inline void add(int x, int val) //一直更新直到最上层 { for (; x \u003c= n; x += x \u0026 -x) tree[x] += val; } inline int sum(int x) //一直加到下标为0 { int ans = 0; //注意赋初始值为0，防止奇奇怪怪的事情  for (; x \u003e 0; x -= x \u0026 -x) ans += tree[x]; return ans; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int a; scanf(\"%d\", \u0026a); add(i, a); } while (m--) { int a, b, c; scanf(\"%d%d%d\", \u0026a, \u0026b, \u0026c); if (a == 1) add(b, c); else printf(\"%d\\n\", sum(c) - sum(b - 1)); } return 0; } 区间修改和单点查询 用到一个比较神奇但是还能理解的东西差分数组。\n用树状数组维护差分数组，以达到快速区间修改和单点查询的操作。\n#include \u003ccstdio\u003econst int maxe = 5e5 + 9; int tree[maxe], n, m; inline void add(int x, int val) //没啥不一样 { for (; x \u003c= n; x += x \u0026 -x) tree[x] += val; } inline int sum(int x) { int ans = 0; for (; x \u003e 0; x -= x \u0026 -x) ans += tree[x]; return ans; } int main() { scanf(\"%d%d\", \u0026n, \u0026m); int a, last = 0; for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a); add(i, a - last); //建立差分数组  last = a; } while (m--) { int a, b, c, d; scanf(\"%d%d\", \u0026a, \u0026b); if (a == 1) { scanf(\"%d%d\", \u0026c, \u0026d); add(b, d); //将区间起点加val  add(c + 1, -d); //将区间终点后一位减val,消除贡献  } else printf(\"%d\\n\", sum(b)); } return 0; } 区间求和 奇妙\n先让我们看一个$long\\space long $的式子： $$ \\begin{aligned} sum([1,r])=\u0026\\sum_{i=1}^{r} a_i=\\sum_{i=1}^r\\sum_{j=1}^i b_j\\=\u0026\\sum_{i=1}^r b_i\\times(r-i+1)\\=\u0026(r+1)\\times \\color{red}{\\sum_{i=1}^r b_i}-\\color{red}{\\sum_{i=1}^r b_i\\times i} \\end{aligned} $$ ~~你感受到数学的魅力了吗？是不是每一个字符你都认识，但是就是不懂它们组合起来是啥意思~~\n亿点点地看，\n$a$ 数组为原始数组(初始值)\n$b$ 数组为树状数组维护的差分数组\n下面把上面那段鬼话变成人话……不用数学符号就是有点长…… $$ \\begin{aligned} \\sum([1,r])=\u0026a_1+a_2+a_3+\\cdots+a_{r-1}+a_r\\=\u0026(b_1)+(b_1+b_2)+(b_1+b_2+b_3)+\\cdots+(b_1+b_2+\\cdots+b_{r-1})+(b_1+b_2+\\cdots+b_{r-1}+b_r)\\=\u0026(b_1\\times r)+(b_2\\times(r-1))+(b_3\\times(r-2))+\\cdots+(b_{r-1}\\times2)+(b_r\\times1)\\=\u0026\\sum_{i=1}^r b_i\\times(r-i+1)\\=\u0026\\color{red}{(r+1)\\times\\sum_{i=1}^r b_i-\\sum_{i=1}^r b_i\\times i} \\end{aligned} $$ 推导之后，我们发现，用树状数组维护两个值($b_i$ 和 $b_i\\times i$)即可。\n二维、多维树状数组 最简单的一种树套树 直接套娃即可 这辈子也别想画出示意图\n在外层树状数组的每个节点上维护一棵树状数组\n查询/更新时使用二重循环即可。\n百度百科 看懂是不可能看懂的，慎重尝试\n#include \u003ccstdio\u003econst int maxe = 5e2 + 9; int n, m, q, tree[maxe][maxe]; inline void add(int x, int y, int val) //注意不能直接调用y,双重循环 { for (int i = x; i \u003c= n; i += i \u0026 -i) { for (int j = y; j \u003c= m; j += j \u0026 -j) { tree[i][j] += val; } } } inline int sum(int x, int y) { int ans = 0; for (int i = x; i \u003e 0; i -= i \u0026 -i) { for (int j = y; j \u003e 0; j -= j \u0026 -j) { ans += tree[i][j]; } } return ans; } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026q); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int a; scanf(\"%d\", \u0026a); add(i, j, a); } } while (q--) { char aa[100]; int a, b, c, d; scanf(\"%s%d%d%d\", aa, \u0026a, \u0026b, \u0026c); if (aa[0] == 'A') add(a, b, c); else { scanf(\"%d\", \u0026d); printf(\"%d\\n\", sum(b, d) + sum(a - 1, c - 1) - sum(b, c - 1) - sum(a - 1, d)); //二维前缀和  //减一不搞好,亲人两行泪  } } return 0; } 树状数组上的二分 建议直接移步平衡树或者线段树。\n摘抄如下：\n类似于线段树上二分，树状数组上也可以进行二分。\n使用树状数组上二分（可能需要预先离散化），可以$O(log\\space{n})$​查询第 $k$​ 小/大元素，实现类似平衡树的效果。\n主要思想是：按二进制位从高到低逐渐二分出答案。\nint kth(int k) { int r = 0, t; for (int i = LOG_N; i\u003e=0; --i) { t = r | 1 \u003c\u003c i; if (t \u003c= n \u0026\u0026 d[t] \u003c k)k -= d[t], r = t; } return r + 1; } ","categories":"","description":"长得像一棵树一样的数组。\n","excerpt":"长得像一棵树一样的数组。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","tags":"","title":"树状数组"},{"body":"欧拉回路 前置知识 图 $G$ 中恰好经过所有边一次(不可重复经过)的通路称作欧拉通路，恰好经过所有边一次的回路称作欧拉回路。\n具有欧拉回路的图称为欧拉图，具有欧拉通路但不具有欧拉回路的图称为半欧拉图。\n存在欧拉通路的充要条件：\n **无向图：**各点连通，没有或仅有两个奇度结点。(偶度保证一入一出，两个奇度可以作为起止节点) **有向图：**各点连通，有一个点出度 = 入度 +1，有一个点入度 = 出度 +1，其余点入度 = 出度。(入度出度相同保证一入一出，其余两点为起止节点)  存在欧拉回路的充要条件：\n  **无向图：**各点连通，所有点为偶度。(存在奇度节点即存在起止点，当起止点相同时，$奇数+奇数=偶数$，因此所有节点均为偶度)\n  **有向图：**各点连通，所有点入度 = 出度。(当其起止点为同一个是，那个点 入度 +1 = 出度 +1，因此所有点入度 = 出度)\n  DFS求解 利用欧拉定理判断出一个图存在欧拉回路或欧拉通路后，选择一个正确的起始顶点，用DFS算法遍历所有的边(每一条边只遍历一次)，遇到走不通就回退。在搜索前进方向上将遍历过的边按顺序记录下来，这组边的排列就组成了一条欧拉通路或回路。\nFleury(佛罗莱)算法 以后有时间再说\n","categories":"","description":"兜兜转转总是你……\n","excerpt":"兜兜转转总是你……\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/","tags":"","title":"欧拉回路"},{"body":"线段树 介绍一下 又是一个倍增思想下奇奇怪怪的东西。\n线段树是一种高效维护(在手不残的前提下)区间信息的数据结构，可以在$O(\\log{n})$​​​​时间复杂度内实现单点修改、区间修改、区间查询等(各种稀奇古怪的)操作。树状数组能够解决的问题理论上(注意空间复杂度)都可以用线段树解决。就是慢了点，空间占得大了点儿\n线段树以树形(满二叉树，二叉搜索树)结构维护着这样一些“线段”(区间)的信息：\n 根结点对应一条$1\\sim n$​的线段。 任何线段$(l\\sim r)$​​​长度$\u003e1$​​​的结点都有恰好两个子结点，分别对应线段 $l\\sim mid$​​​ 与 $mid+1\\sim r$​​​，其中 $mid=\\lfloor\\dfrac{l+r}{2}\\rfloor$​​​。  线段树上结点的深度每增大 $1$，线段长度就折半，因此线段树深度为 $\\log{n}$​​，由此保证了单点修改复杂度为$O(\\log{n})$​。\n对于任意区间，都可以在线段树上找到不重叠的至多 $2\\times\\log{n}$​ 条线段（每种深度至多两条）将其恰好覆盖，这保证了线段树区间操作复杂度为 $O(\\log{n})$​。\n规定根结点编号为 $1$​​​​​​，编号为 $i$​​​​​​ 的结点的两个子结点（若存在）编号为 $2i$​ ​​​​​与 $2i+1$ ​​​​​​。这样定义的结点编号最大不会超过 $4n$​​​​​。\n一棵维护最小值的线段树大概长这样：线段树所占空间的计算 这一段不看不会也罢，只需要记住开 $4n$​ 个数组就行了。\n关于线段树的空间：如果采用堆式存储(大部分)($2i$​​是 $i$​​的左儿子，$2i+1$​​是 $i$​​的右儿子)，若有 $n$​​ 个叶子结点，则 $d$​​ 数组的范围最大为 $2^{\\lceil\\log{n}\\rceil+1}$​。 分析：容易知道线段树的深度是 $\\lceil\\log{n}\\rceil$​的，则在堆式储存情况下叶子节点（包括无用的叶子节点）数量为 $2^{\\lceil\\log{n}\\rceil}$​个，又由于其为一棵完全二叉树(补齐未使用节点)，则其总节点个数 $2^{\\lceil\\log{n}\\rceil+1}-1$​。当然如果你懒得计算的话可以直接把数组长度设为 $4n$​，因为 $\\dfrac{2^{\\lceil\\log{n}\\rceil+1}-1}{n}$​的最大值在 $n=2^x+1(x\\in N_+)$​时取到，此时节点数为 $2^{\\lceil\\log{n}\\rceil+1}-1=2^{x+2}-1=4n-5$​。\n正题来了 其实，没啥好说的，很好理解，很不好背……\n下面这4个函数，构建了最最最简单的线段树，效果大概可树状数组一样。\nps：变量名尽量统一，好处多多。\n宏定义 有效降低代码长度、出错概率以及Debug时间。\n如果你很猛，请跳过这一段……\n使用位运算是因为本来线段树就很慢，所以要用快一点的位运算\n#define Mid ((l + r) \u003e\u003e 1) //位运算,相当于(l + r)/2 #define Len (r - l + 1) //区间长度,注意+1 #define Root 1, 1, n //根节点调用 #define Lpos pos \u003c\u003c 1 //左儿子节点编号,相当于pos*2 #define Rpos Lpos | 1 //右儿子节点编号,相当于Lpos+1 #define Lson Lpos, l, Mid //左儿子调用 #define Rson Rpos, Mid + 1, r //右儿子调用 #define This pos, l, r //当前节点调用 update函数 更新节点信息\n视维护啥而定\nfor example:\ninline void upd(int pos) { tree[pos] = tree[Lpos] + tree[Rpos]; //维护区间和  tree[pos] = std::max(tree[Lpos], tree[Rpos]); //维护区间最大值 } build函数 从原数组构建线段树\ninline void build(int pos, int l, int r)//pos当前节点编号，l区间右端点，r区间左端点 { if (l == r)//区间长度为1则赋值原数组  tree[pos] = in[l];//注意是l而不是pos，是区间在原数组中维护的位置而不是节点编号  else { build(Lson);//递归建树  build(Rson); upd(pos);//更新当前节点信息  } } change_point函数 单点修改线段树上某一位的值\nvoid cpit(int pos, int l, int r, int point, int val) //pos当前节点编号，l右端点，r左端点，point修改目标编号，val修改值 { if (l == r) //区间长度为1，进行修改，结束递归  { tree[pos] = val; //根据题意自行更改  return; } if (point \u003c= Mid) //如果区间包含左儿子，递归更改  cpit(Lson, point, val); else //如果区间包含右儿子，递归更改  cpit(Rson, point, val); upd(pos); //更新当前节点信息 } check_block函数 区间(和、最大值等)查询\ninline int fblk(int pos, int l, int r, int L, int R) //pos当前节点编号，l右端点，r左端点，L查询区间左端点，R查询区间右端点 { if (L \u003c= l \u0026\u0026 R \u003e= r) //当前线段树上的线段被查询区间完全包含，返回当前线段维护的信息  { return tree[pos]; } stg(This); //下放当前线段的标记  if (R \u003c= Mid) //只包含左儿子，递归查找左儿子，直到被查询线段全部被包含  return fblk(Lson, L, R); if (L \u003e Mid) //只包含右儿子，递归查找右儿子，直到被查询线段全部被包含  return fblk(Rson, L, R); return fblk(Lson, L, R) + fblk(Rson, L, R); //左右儿子均含有被查询区间，则同时查找两个儿子 } “懒”标记 区间 $[l,r]$时，如果修改所有与 $[l,r]$相关的线段，那么时间复杂度将退化为 $O(n)$​。那还不如不写\n线段树通过引入懒标记把对整条线段的修改操作暂存在结点上，当需要访问子节点时再把修改操作应用到子结点上。\n真理：人类因懒而进步\n针对于每个节点开一个(可能不止)标记位，注意数组长度仍为 $4n$。\n 维护多个标记时注意下放的顺序，保证先下放的标记不影响后下放的标记。  ​\t**例：**同时维护加法标记和乘法标记时，应先下放乘法标记，再下放加法标记。\n 标记累加时注意其正确性，包括是否要改变其他标记。  ​\t**例：**乘法标记叠加时，加法标记也应乘相应修改值。\nget_tag函数 打标签\ninline void gtg(int pos, int l, int r, int val) //pos当前节点编号，l右端点，r左端点，val增加量 { tag[pos] += val; //标签累加  tree[pos] += Len * val; //维护区间和，总增加量=单点增加量*区间长度 } send_tag函数 将标签下方给两个儿子\ninline void stg(int pos, int l, int r) //pos当前节点编号，l右端点，r左端点 { gtg(Lson, tag[pos]); //把标签下放给左儿子  gtg(Rson, tag[pos]); //把标签下放给右儿子  tag[pos] = 0; //将pos位标签置0(标签以下放给儿子) } change_block函数 区间修改\ninline void cblk(int pos, int l, int r, int L, int R, int val) //pos当前节点编号，l右端点，r左端点，L修改区间左端点，R右端点，val修改值 { if (L \u003c= l \u0026\u0026 R \u003e= r) //当前线段树上的线段被查询区间完全包含，打标记  { gtg(This, val); return; } stg(This); //若两个儿子只有一个被包含，则下方当前线段标记，更新包含修改区间的儿子  if (L \u003c= Mid) //只包含左儿子，递归查找左儿子，直到被修改线段全部被包含  cblk(Lson, L, R, val); if (R \u003e Mid) //只包含右儿子，递归查找右儿子，直到被修改线段全部被包含  cblk(Rson, L, R, val); upd(pos); //更新当前节点信息 } 维护一些奇奇怪怪的东西 单表一些你想也想不到的烂七八糟的用线段树维护的东西。\n  区间最大子段和\n  最大子段\n  最大前缀\n  最大后缀\n    序列操作\n  归零标记\n  取反标记\n  区间和\n  连续前缀0或1个数\n  连续后缀0或1个数\n    ………………………………\n  怎么样，意想不到吧\n为了方便，毕竟谁也不想写 $5、6$ 个update函数去逐一维护。\n所以，C++的高级语法 bulingbuling 的出现了。—————-\u003e struck结构体 + operator运算符重载\n使用结构体记录所有需要维护的信息并通过 operator + 实现合并能够有效降低代码难度：\n空间的一点儿优化——动态开点线段树 引子 还是先搞一个非常形象的小故事吧。\n​ 首先，你想象自己是一位古代的帝王；你精力旺盛，辛勤耕耘20余年，终于在后宫三千佳丽的帮助下，成功为人类的繁衍生息做出了巨大的贡献。\n​ 那么，问题来了。你的儿子女儿加在一起已经快赶上一个师~~(手动狗头)~~的规模了，而恰好你现在手里没有钱(你并不被允许使用那么多内存)，不可能让你的所有子女都住上气派辉煌的宫殿，其中大部分不受宠的就只能住在一些破旧的偏殿里(你在自己的机器中能申请到内存)。\n​ 现在，另一个国家的元首(评测机)来你国访问，你开始炫耀起你对人类所做出的贡献。这时候，正是展现国家经济军事实力、皇帝大臣精神面貌的时候，你当然不能让来访的外国人知道你手里没钱，连自己子女的房子都四处漏风，否则对方就会认为你好欺负，来攻打你(评测机返回MLE，把你的分数打掉)。\n​ 所以，你想到了一个损招：当且仅当你要展示第 $i$ 个儿子时，才把他的房子装修一下，搞好一点，装装样子。至于那些对方看不见的，就爱咋咋地。因为对方时间有限，并不会跟着你看很多的子女(然而仅有的几个住在好地方的又不够展现帝国雄风)，走访的并不会太多，因此并不需要改造太多，国家这点钱还是出得起的(你并没有MLE，骗过了评测机，评测机认为你并不好惹，给了你AC)。\n该正经了 当需要维护的区间很长(如 $n=10^9$)但操作次数有限(如 $m=10^5$​)时，如果建立出完整的线段树，空间复杂度为 $O(n)$，无法接受。\n但可以发现每次操作涉及到的线段数为 $O(\\log{n})$级别，完成所有操作涉及到的区间个数级别为 $O(m\\space\\log{n})$，这是可以接受的空间开销。\n于是我们放弃之前用数组存储线段树上所有结点的做法，而是在访问到未创建结点时为其分配存储位置，这样的线段树叫做动态开点线段树。\n线段树上二分 ~~与树状数组上二分类似，~~线段树上也可以进行二分。概括地说，线段树上二分的实质是利用线段树上当前结点及其两个子节点维护的信息快速判断要查找的位置在左右哪个区间中。由于线段树的深度为 $\\log{n}$，所以线段树上二分的复杂度为 $O(\\log{n})$。\n权值线段树 与树状数组维护可重集合的 count 数组类似，线段树也可以用来维护可重集合的 count 数组，这样的线段树常被称作权值线段树。在使用动态开点线段树实现权值线段树时可以放松对权值值域的限制（权值甚至可以取为负数！），这与处理较大权值时需要事先离散化的树状数组相比具有巨大的优势。\n线段树优化建图 总结 在更多更灵活的题目中，线段树等数据结构往往被用来快速维护一些区间信息，即一种优化暴力的手段。\n这一类问题中，数据结构的维护只是最后一步，难点往往在于想出第一步的 $O(n^2)$或 $O(nm)$的暴力。\n解决这类优化问题时，一般都是在得到暴力解法后，将要实现的操作都列出来，再选择合适的数据结构维护这些操作。\n考场上遇到这类题目一定要先写出暴力，拿到尽可能多的分数！！\nmd要是遇到线段树的题，一首《凉凉》送给头秃的自己\n","categories":"","description":"一棵由线段构成的树。\n","excerpt":"一棵由线段构成的树。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":"","title":"线段树"},{"body":"二分图匹配 前置知识——二分图 首先，要明白什么是二分图(又称作二部图)。\n形象的描述一下，现在你是某市的市长，而一条大河从你的城市中心穿流而过。所以，你为了使你的城市交通遍历，促进城市发展，你决定在这条河上建桥，以连接河两岸的路口。\n如上图，所有河上的桥和路口就组成了一个二分图。\n二分图的定义：如果顶点 $V $ 可分割为两个互不相交的子集 $(A,B)$，并且图中的每条边 $(i，j)$ 所关联的两个顶点 $i$ 和 $j$ 分别属于这两个不同的顶点集 $(i \\in A,j \\in B)$，则称图G为一个二分图。简而言之，就是顶点集 $V$ 可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。\n意思就说，你把一个图的顶点分到河的两岸，图上所有的边只能是桥，不能是陆地上的公路，即不能在河的一侧修建边。\n区别二分图，关键是看点集是否能分成两个独立的点集。无向图G为二分图的充要条件是，$G$ 至少有两个顶点，且其所有环的长度均为偶数，不存在奇环。可以存在偶环，如上图 $2\\rightarrow7\\rightarrow3\\rightarrow8\\rightarrow2$ 就是一个偶环，但上图满足二分图。任何无回路的的图均是二分图。\n**总结：**DFS/BFS，如发现奇环则不是二分图，否则是。\n充要条件的证明(百度百科)\n更简单的：因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。\n最大匹配 **匹配：**从二分图中选择 $n$ 条边，保证没有任何一个顶点是两条或以上边的终点。\n一个形象的事情：\n现在你变身成为了月老，发现今天有 $n$ 个男生和 $m$ 个女生在你的庙(月老庙)前许愿求姻缘。你今天很高兴，决定帮帮他们。他们每个人祈祷的时候都说了他们心仪的对象，你将他们整理了一下，将可能(符合双方的要求 -__- )的两个人之间连一条线(假设没有gay)，建立了一个二分图。\n这时候，作为善良的你，需要履行帮助人类繁衍生息的职责，因此要促成尽可能多的情侣狗，问最多能搞成几对？\n数学表示：若 $E'\\in E$，且 $E'$ 中任意两条边不共用同一个顶点，则称 $E'$ 是二分图 $G$ 的一个匹配。\n**最大匹配：**边数最多的匹配(促成的情侣狗最多)。即 $E'$ 中边数最大。\n**完美匹配：**所有向你求愿单身狗都变成了情侣狗。即 $E'=E$。\n匈牙利算法——寻找最大匹配 交替路与增广路 **交替路：**从一个未匹配点出发，依次经过非匹配边、匹配边，并且第一条和最后一条边均为非匹配边，形成的路径叫交替路。\n**增广路：**从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路。\n  红色的边为当前的匹配   紫色的边为当前匹配的增广路   将增广路中匹配的边和非匹配变交换，匹配边数 $+1$   匈牙利算法的真面目 匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。(看完的都是好宝宝)\n有意思的博文一篇\n简单一点，就是一个不断逼近答案的过程。\n对于每个节点，执行如下步骤：\n 如果连接这个节点的任何一条边可以被选中，则将这条边加入匹配，返回TRUE。 如果莫得可以加入的边了，那么可以推导出连接它的所有边均为非匹配边。然后开始逐个寻找增广路，直到全部遍历完成(返回FALSE)或者把其中的某一条边加入匹配(即找到了一条增广路，返回TRUE)。  这个东西的烦人之处在于这玩意的代码………………难以理解，需得手推\n洛谷P3386\n#include \u003ccstdio\u003e#include \u003cbitset\u003e#include \u003cvector\u003econst int maxe = 600; int n, m, e, ans, pot[maxe]; //一共有n个男生,m个女生,共e条边,pot[i]表示第i个女生属于的男生编号 std::bitset\u003cmaxe\u003e vis; //标记是否访问过(名花有主) std::vector\u003cint\u003e con[maxe]; //以男生的角度记录这张图(因为要遍历男生找女生) inline bool dfs(int now) { for (auto i : con[now]) //遍历他有好感的所有女生  { if (!vis[i]) //如果这个女生现在莫得npy  { vis[i] = 1; //表示你就是我的了  if (!pot[i] || dfs(pot[i])) //如果你原先没有npy或者前男友鱼塘里还有  { pot[i] = now; //你现在彻底是我的了  return true; //表示我找到npy了(-_-)  } } } return false; //我没有找到(T_T) } int main() { scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026e); for (int i = 0; i \u003c e; i++) { int a, b; scanf(\"%d%d\", \u0026a, \u0026b); con[a].push_back(b); } for (int i = 1; i \u003c= n; i++) { vis.reset(); //每次都重新分配  if (dfs(i)) //如果现在的这个男生找到了npy,就又多了一对情侣  ans++; } printf(\"%d\", ans); return 0; } 时间复杂度 $O(nm)$ 。\n最大匹配的引申 最小边覆盖= n - 最大匹配 一个边集里的边能覆盖所有的点，最小边覆盖是满足这个要求的所有边集中边数最少的一个。\n证明：\n因为边数越小越好，则每条边能覆盖的点一定是越多越好(尽量每条边都覆盖2个点)，而最大匹配找出了最多覆盖2个点的边。而剩下的就只能一条边覆盖一个点了。\n所以，设总顶点数为 $n$，最大匹配边为 $m$，则可以得到 $$ 最小边覆盖=m+(n-2m)=n-m $$\n最小点覆盖 = 最大匹配 **最小点覆盖：**假如选了一个点就相当于覆盖了以它为端点的所有边。最小点覆盖就是选择最少的点来覆盖所有的边。\n**证明：**由最大匹配可知，不存在一条边的两个端点均没有被在最大匹配集合中的边所连接的情况(否则这条边就可以加入匹配)。因此，我们可以将边分为两类：匹配边和非匹配边；也可以将点分为两类：是匹配边的端点和不是匹配边的端点。\n如上图，匹配边，非匹配边，匹配边的端点，不是匹配边的端点。\n在匹配边的端点中选择有相邻不是匹配边的端点的点即可。\n这样的点保证之多有最大匹配个。\n首先，我们只要没傻到在同一条匹配边上选择两个点就行，这样，所有的匹配边均可被覆盖。\n同一条匹配边上的端点不可能同时与不是匹配边的端点相邻，否则构成一条增广路(如上图，若有11号节点与9号节点连接，则 $11\\rightarrow9\\rightarrow5\\rightarrow10$ 构成增广路)。\n因此，最小点覆盖 = 最大匹配。\n最大独立集 = n - 最小点覆盖 选出一些顶点使得这些顶点两两不相邻，则这些点构成的集合称为独立集。找出一个包含顶点数最多的独立集称为最大独立集。\n**证明：**去掉最小点覆盖的顶点后，所有点之间不连通(因为删去最小点覆盖保证所有边均删除，因此不会出现连通)。\n最小不可重链覆盖 有权最大匹配等 参见网络流和费用流。\n","categories":"","description":"月老狂喜……\n","excerpt":"月老狂喜……\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/","tags":"","title":"二分图匹配"},{"body":"","categories":"","description":"它为啥子不能修改！！！\n","excerpt":"它为啥子不能修改！！！\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/st%E8%A1%A8/","tags":"","title":"ST表"},{"body":"当你啥也不会的时候，充分利用C++ STL模板可以让你的暴力多得几分。\n","categories":"","description":"","excerpt":"当你啥也不会的时候，充分利用C++ STL模板可以让你的暴力多得几分。\n","ref":"/oiblogs/others%E6%9D%82%E9%A1%B9/","tags":"","title":"杂项"},{"body":"字典树 这是一棵神奇的树 字典树，顾名思义，就是一个字典。\n字典树，又称前缀树，作用是储存一些字符串……方便查询与修改。\n具体来说，就是将每一个字符串变成树上的一条链，从 $root$ 到每个叶子节点就是我们要储存的一个字符串。\n举个栗子，我们要储存 $ababa$ 、$badab$ 、$adace$ 、$abace$ 、$cdeab$ 、$abcab$ 、$ccc$ ，就是下图：\n当然，我们也可以在边上存储字符，具体操作可按照个人喜好来搞，均可以实现字典树的种种操作。\n对于字符串 $aba$ 改如何储存呢？很简单，在其结尾打一个 $tag$ 即可。\n基本操作 注意，我们下面讨论的都是节点存储字符的情况，而并非字符存储在边上。其实都差不多，就是如何理解的问题。\n结构 int tot; //记录总节点个数，用于分配新的节点 struct node //每个节点储存节点编号、节点上的字符和是否是结尾 { int id; char val; bool tag; }; std::vector\u003cnode\u003e next[maxe]; //储存每个节点的儿子,便于查找 插入 inline void ins(char *in) //本来应该是dfs的,只不过优化为循环了 { int now = 0, len = strlen(in); //标记当前节点的编号,字符串的长度  for (int i = 0; i \u003c len; i++) { int ci = next[now].size(); //遍历子节点  bool is = 0; //记录是否找到可以用的链  for (int j = 0; j \u003c ci; j++) { if (next[now][j].val == in[i]) { if (i == len - 1) //如果是字符串结尾就打tag  next[now][j].tag = 1; is = 1; now = next[now][j].id; //跳转到这个儿子，继续ins  break; } } if (!is) //如果没有匹配的节点,就要新建一个  { next[now].push_back(node{++tot, in[i], i == len - 1 ? true : false}); now = tot; //跳转到新建的节点  } } } 查找 inline bool find(char *in) //本来应该是dfs的,只不过优化为循环了 { int now = 0, len = strlen(in); //标记当前节点的编号,字符串的长度  for (int i = 0; i \u003c len; i++) { int ci = next[now].size(); //遍历子节点  bool is = 0; //记录是否找到可以用的链  for (int j = 0; j \u003c ci; j++) { if (next[now][j].val == in[i]) { is = 1; //标记找到了  if (i == len - 1) //如果是结尾,则判断是否有tag(若没有,就是字典中某个字符串的前缀)  is = next[now][j].tag; now = next[now][j].id; break; } } if (!is) //如果没找到合适的子节点,说明树中没有这个字符串  return false; if (i == len - 1) //如果全部匹配,则字典中有所查询的字符串  return true; } } 另一种 我们还可以按照边来储存字符，并且我们可以在一定程度上用时间换空间(其实只是减小了常数)。\n直接对于每个节点开出字符范围大小的数组，对应位置储存对应字符的儿子节点(如果有的话)，这样就省去了查找子节点是啥子的时间，但是同时要在空间上做出一定的牺牲，适用于字符范围较小的字典。\nFaiOJ #30034. 「一本通 2.1 例 2」图书管理 就是板子\n#include \u003ccstdio\u003estruct node { int next[60];//我们直接开出全部字符范围,然后按照下标存储  bool tag; //0~29 30~59 } nodes[3000000]; int root = 1, tot = 1; inline void ins(char *in) { int pos = root, val;//val就是让你省一点代码  for (; *in; ++in) //这玩意和 for(int i = 0;i \u003c len;i++)一个意思  { val = (*in) \u003e= 'A' \u0026\u0026 (*in) \u003c= 'Z' ? (*in) - 'A' : (*in) - 'a' + 30;//找到相对应的下标  if (!nodes[pos].next[val])//没有这个节点  nodes[pos].next[val] = ++tot; pos = nodes[pos].next[val];//跳转到下一个,继续插入  } nodes[pos].tag = true;//结尾打tag } inline bool find(char *in) { int pos = root, val; for (; *in; ++in) { val = (*in) \u003e= 'A' \u0026\u0026 (*in) \u003c= 'Z' ? (*in) - 'A' : (*in) - 'a' + 30; if (!nodes[pos].next[val]) return false; pos = nodes[pos].next[val]; } return nodes[pos].tag\u003e0?true:false; } int len; char ord[10], name[500]; int main() { scanf(\"%d\", \u0026len); while (len--) { scanf(\"%s %[^\\n]\", ord, name); if (ord[2] == 'd') ins(name); else printf(\"%s\\n\", find(name) ? \"yes\" : \"no\"); } return 0; } 这玩意能干啥 字典树因为其特有的结构，在大量字符串的查找、修改、比较中有较大的优势。\n还可以进行转化，用于比较二进制($k$进制)下的数字大小等。亦可以用于关于前缀的若干问题。\n但是，还是那句话，数据结构都是用来在暴力的情况下进行优化的……\n$01$​-Trie 没错，这个东西用来搞二进制的 01-trie是将整数的二进制表示（位数固定，补前导零）看做一个字符串，按二进制位从高到低的顺序插入构建出的字符集为 ${0,1}$ 的字典树。\n事实上，与平衡树类似，01-trie也可以用于维护一个有序集合，支持插入、删除、数查排名、排名查数等操作。但由于空间开销大等原因，很少见到这样使用01-trie的OI选手。(我会平衡树，还要这玩意干屁)\n01-trie 最常见的应用是快速计算数 $x$ 与字典树中所有数异或结果的最大值或最小值。以最大值为例，具体的做法是从树根开始（即按二进制位从高到低）贪心：\n 若存在与 $x$ 当前位上的值相反的边，则走这条边，使这一位的异或结果成为 $1$； 若不存在，则走相同的边，使这一位的异或结果为 $0$。  答案从高位到低位~~(说话算数的到说话不算数的)~~依次构造，正确性显然。\n板子 FaiOJ #30050. 「一本通 2.3 例 2」The XOR Largest Pair\n","categories":"","description":"让一部字典长成一棵树。\n","excerpt":"让一部字典长成一棵树。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E5%85%B8%E6%A0%91/","tags":"","title":"字典树"},{"body":"差分约束 难懂但是比较全的博文\n这是啥子? 简单来说，差分约束就是把不等式转变成图的一种思想。因为题目可能会给你很多不等式，使用数学方法很有可能无解，而且难以找到这些不等式之间的联系。但是当我们把它们转化成图之后，就可以使用图论的思想来解题。\n通常，差分约束是用来解决求一组形如 $a-b\\le{c}$ 的不等式的可能最大/最小解。\n对于每一个 $i-j\\le z$，建立一条从 $j$ 到 $i$ 权值为 $z$ 的有向边，将求解 $a-b\\le{c}$ 的最大/最小值转化为求从 $b$ 到 $a$ 的最短/最长路径长度。\n三角不等式 若有一个不等式组： $$ \\begin{aligned} \\left{\\begin{array}{lr} \u0026C-B\\le{a}\\\u0026C-A\\le{b}\\\u0026B-A\\le{c} \\end{array} \\right. \\end{aligned} $$ 则根据上述条件，可以建图如下：\n由不等式相加组合，可得到 $max(C-A)=min(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最短路。\n对于最大值： $$ \\begin{aligned} \\left{\\begin{array}{lr} \u0026C-B\\ge{a}\\\u0026C-A\\ge{b}\\\u0026B-A\\ge{c} \\end{array} \\right. \\end{aligned} $$ 由不等式相加组合，可得到 $min(C-A)=max(b,a+c)$，这也正好对应图中 $A$ 到 $C$ 的最长路。\n因此，对三角不等式加以推广，变量 $n$ 个，不等式 $m$ 个，要求 $C-A$ 的最大/最小值，便就是求取建图后 $A-C$ 的最短/最长路。\n另：\n 若出现 $C-A=b$ 的情况，可以拆分为 $C-A\\ge{b}$ 和 $C-A\\le{b}=A-C\\ge{-b}$ 或 $C-A\\ge{b}=A-C\\le{-b}$ 和 $C-A\\le{b}$ 两条边。 若出现 $C-A\u003eb$的情况，因为题目中大多是整形数据，因此变为 $C-A\\ge{b+1}$ 即可。 值得注意的一点是：若建立的图不联通，则需要加入一个超级源点 $S$，在 $S$ 和其他的每个点之间建立一条权值为 $0$ 的无向边，然后从 $S$ 点开始求解即可。  无名算法 流程：\n 构建基于不等式的关系图。 跑最短路(注意，最长路可以通过spfa求出来，只需要改下松弛的方向即可，即if(dis[v] \u003c dis[u] + val(u,v)) dis[v] = dis[u] + val(u,v)。当然我们可以把图中所有的边权取负，求取最短路，两者是等价的。) 建图后不一定存在最短路/最长路，因为可能存在负环/正环，判断差分约束系统是否存在解一般判环即可。  一些注意事项：\n 根据条件把题意通过变量组表达出来得到不等式组，注意要发掘出隐含的不等式，比如说前后两个变量之间隐含的不等式关系。 建好图之后直接spfa求解，一般不能用dijstra算法，因为通常存在负边。 注意初始化的问题。  洛谷P5960\n","categories":"","description":"不等式和最短路到底有什么关系？\n","excerpt":"不等式和最短路到底有什么关系？\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","tags":"","title":"差分约束"},{"body":"01分数规划 问题 使两个线性函数的比值最大或最小的问题，称作分数规划问题或双曲线问题。\n而01分数规划和01背包问题差不多：\n我们现在有 $n$ 个物品，每一个物品均有一个 $val$ 和 $cost$，$x_i\\in[0,1]$ 表示第 $i$ 物品是(1)否(0)选择。\n从 $n$ 个物品必须选择 $k$ 个，求下式的最大/最小值。 $$ \\frac{\\sum_{i=1}^nval_i\\times{x_i}}{\\sum_{i=1}^ncost_i\\times{x_i}} $$\n二分解法 二分在这边\n假设答案为 $ans$ $$ ans=min(\\frac{\\sum_{i=1}^nval_i\\times{x_i}}{\\sum_{i=1}^ncost_i\\times{x_i}}) $$ 则一定有 $$ ans\\times{\\sum_{i=1}^ncost_i\\times{x_i}}=\\sum_{i=1}^nval_i\\times{x_i} $$ 即 $$ \\sum_{i=1}^nval_i\\times{x_i}-ans\\times{\\sum_{i=1}^ncost_i\\times{x_i}}=0 $$ 所以，将每个物品的权值置为 $v-r\\times{c}$，排序后，判断前k个物品的权值和与 $0$ 比较，进而缩小二分界限，得出 $ans$ 值。\n最大比率环 和01分数规划思路基本相同，建立好模型后二分答案。\n通过判断图内是否存在负环来调整二分界限\n","categories":"","description":"解分式？\n","excerpt":"解分式？\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/01%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/","tags":"","title":"01分数规划"},{"body":"","categories":"","description":"想象一下，某一天，Hash函数被证明可以逆推导，那将是一场灾难。\n","excerpt":"想象一下，某一天，Hash函数被证明可以逆推导，那将是一场灾难。\n","ref":"/oiblogs/data%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/hash%E8%A1%A8/","tags":"","title":"Hash表"},{"body":"坐标之间的常用距离 通常，OI中使用到的两点之间坐标(针对于维度大于一的坐标系)通常用如下三种。\n欧几里得距离 定义为以两点为端点的线段的长度。\n如下图，欧几里得距离为线段d的长度。\n$S=\\sqrt{\\abs{1-3}^2+\\abs{5-2}^2}\\approx3.61$\n曼哈顿距离 两点 $x,y,z\\space\\cdots\\cdots$ 坐标差的绝对值之和。\n如下图，曼哈顿距离为线段d和线段g的长度之和。\n$S=\\abs{5-2}+\\abs{1-3}=3+2=5$\n切比雪夫距离 两点 $x,y,z\\space\\cdots\\cdots$ 坐标差的绝对值的最大值。\n如下图，切比雪夫距离为线段d和线段g中长度较大的那一个，即线段d。\n$S=max(\\abs{5-2},\\abs{1-3})=max(3,2)=3$\n坐标转化 一般提示距离的字眼：\n **欧几里得距离：**平面最短距离。 **曼哈顿距离：**从一个点出发，可以上下左右移动到另一点，移动的最小步数。 **切比雪夫距离：**从一个点出发，可以向八个方向（包括斜向）移动，移动点最小步数。(因为斜着移动同时改变两个坐标)  曼哈顿距离和切比雪夫距离之间可以通过坐标的变换进行相互转化：\n  将每一个点 $(x,y)$ 转化为 $(x+y,x−y)$ ，新坐标系下的切比雪夫距离即为原坐标系下的曼哈顿距离。\n  将每一个点 $(x,y)$ 转化为 $(\\frac{x+y}{2},\\frac{x−y}{2})$，新坐标系下的曼哈顿距离即为原坐标系下的切比雪夫距离。\n  这一段背住得了，证明不看也罢。\n","categories":"","description":"嗯？两个点之间的距离竟然有好几种？\n","excerpt":"嗯？两个点之间的距离竟然有好几种？\n","ref":"/oiblogs/graph%E5%9B%BE%E8%AE%BA/%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA%E6%B3%95/","tags":"","title":"坐标距离"},{"body":"为了练习英语 as well as 对Docsy做出一点贡献并且让更多中国人看得懂,翻译一下官方文档。\n正在不断完善中……\n","categories":"","description":"","excerpt":"为了练习英语 as well as 对Docsy做出一点贡献并且让更多中国人看得懂,翻译一下官方文档。\n正在不断完善中……\n","ref":"/docsy-docs-zh/","tags":"","title":"Docsy中文文档"},{"body":"数学表示  $x|y$ ：$x$ 整除 $y$，即存在 $d\\in Z$ 使得 $y=dx$  ","categories":"","description":"稀奇古怪……\n","excerpt":"稀奇古怪……\n","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E6%95%B0%E5%AD%A6%E8%A1%A8%E7%A4%BA/","tags":"","title":"数学表示"},{"body":"","categories":"","description":"","excerpt":"","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","tags":"","title":""},{"body":"矩阵乘法 基本概念 $n$ 行 $m$ 列个元素有规律的排列在一起，构成一个矩阵，记作 $A=(a_{i,j})_{n\\times m}\\in R^{n\\times m}$。\n若 $n=m$ ，则这个矩阵为 $n$ 阶矩阵。\n基本运算规则 加减法 对于两个矩阵 $A=(a_{i,j})_{a\\times b}$ 和 $B=(b_{i,j})_{x\\times y}$，当且仅当 $a=x$ 且 $b=y$ 时，$A-B$ 和 $A+B$ 有意义。\n$A-B=$\n乘法 ","categories":"","description":"","excerpt":"矩阵乘法 基本概念 $n$ 行 $m$ 列个元素有规律的排列在一起，构成一个矩阵，记作 $A=(a_{i,j})_{n\\times …","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/oiblogs/math%E6%95%B0%E8%AE%BA/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"分享一下。\n","categories":"","description":"","excerpt":"分享一下。\n","ref":"/oiblogs/","tags":"","title":"OIblogs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"\r #td-cover-block-0 { background-image: url(/about/featured-background_hue62fbdd9b7ba23774b3e433beda0a2cf_1460395_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/about/featured-background_hue62fbdd9b7ba23774b3e433beda0a2cf_1460395_1920x1080_fill_q75_catmullrom_top.jpg); } }  关于Senie 一个由@曦曦赫赫搭建的静态网站。\r       本网站由@曦曦赫赫搭建,Hugo提供驱动支持,使用Docsy主题,源代码托管于Github。\n    本网站完全开源,源码下载请移至Github\r\r   --\r 高清底图下载:\r登录界面背景图\r每日单词和关于界面背景图\r\r   ","categories":"","description":"","excerpt":"\r #td-cover-block-0 { background-image: …","ref":"/about/","tags":"","title":"关于"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"搜索结果"},{"body":"\r #td-cover-block-0 { background-image: url(/featured-background_hu5240950adfa04ce92018c6fc0664f830_1379064_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hu5240950adfa04ce92018c6fc0664f830_1379064_1920x1080_fill_q75_catmullrom_top.jpg); } }  欢迎访问Senie:曦曦呵呵的个站! 每日单词\r\r红楼梦 \r\rOI blogs \r\r汉译英 \r\r让我们”愉快”的学习并享受万维网所带来的“方便“叭!\n \r       这是由曦曦呵呵在“百忙之中“搭建的小型个站,最主要的目的是激励自己学习,而他愿意把自己学习的过程分享一下,所以Senie诞生了。\n下面是Senie各部分的介绍。\n      每日单词!  这是一个每天提供新鲜出炉(刚刚从不知道啥地方看见的)10个陌生单词,寄希望于把它们都背下来。\n虽然,这很难,但是我们要努力做到。可能性\n   OI blogs!  作为一名OIer不能忘了主业竞赛!\n对于题解和各种奇奇怪怪的算法,也需要一个存储和共享的地方。\n因为,拥抱开源!!!\n   汉译英!  当然,背单词还不够,还得会用。\n而汉译英确实是个好方法。\n   红楼梦现代文翻译!  因为,据说,高考要考名著阅读,其中有红楼梦!!!\n正好,边翻译边看了一遍。对于古文翻译和名著阅读都有好处。(夺聪明)\n   Docsy中文文档!  高情商:对Docsy开源社区做出贡献!\n低情商:练习英语……\n   杂谈!  如其名,一个充满神奇东东的地方。\n     友情链链接: 洛谷\n在线结点图编辑器\nC++手册\nGeoGebra\n算法动画\n   ","categories":"","description":"","excerpt":"\r #td-cover-block-0 { background-image: …","ref":"/","tags":"","title":"Senie"},{"body":"这可能才是一个真正的blog,分享一些奇奇怪怪偏门左道的计算机杂谈及各种有趣的资料。\n","categories":"","description":"","excerpt":"这可能才是一个真正的blog,分享一些奇奇怪怪偏门左道的计算机杂谈及各种有趣的资料。\n","ref":"/tools-others/","tags":"","title":"杂谈"},{"body":"  #td-cover-block-0 { background-image: url(/daily-words/featured-background_hue62fbdd9b7ba23774b3e433beda0a2cf_1460395_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/daily-words/featured-background_hue62fbdd9b7ba23774b3e433beda0a2cf_1460395_1920x1080_fill_q75_catmullrom_top.jpg); } }  每日单词 每天一背,开开心心。\n       2021-10-\n     2021-10-\n    --  2021-10-\n     2021-10-\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/daily-words/","tags":"","title":"每日单词"},{"body":"这里时不时地可能翻译一些“心灵鸡汤”或者自己喜欢的一点儿东西,具体视情况而定。\n","categories":"","description":"","excerpt":"这里时不时地可能翻译一些“心灵鸡汤”或者自己喜欢的一点儿东西,具体视情况而定。\n","ref":"/to-en/","tags":"","title":"汉译英"}]